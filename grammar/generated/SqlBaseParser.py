# Generated from SqlBase.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,295,1319,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,1,0,1,0,5,0,175,8,0,10,0,12,0,178,9,0,1,0,1,0,1,1,1,1,1,
        1,1,2,1,2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,6,3,6,199,
        8,6,3,6,201,8,6,1,7,3,7,204,8,7,1,7,1,7,1,7,1,8,1,8,1,9,1,9,1,9,
        1,9,5,9,215,8,9,10,9,12,9,218,9,9,1,10,1,10,3,10,222,8,10,1,10,3,
        10,225,8,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,5,11,235,8,11,
        10,11,12,11,238,9,11,1,11,1,11,1,12,1,12,1,12,1,12,5,12,246,8,12,
        10,12,12,12,249,9,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,1,14,
        1,14,5,14,261,8,14,10,14,12,14,264,9,14,3,14,266,8,14,1,14,1,14,
        1,14,1,14,1,14,5,14,273,8,14,10,14,12,14,276,9,14,3,14,278,8,14,
        1,14,3,14,281,8,14,1,14,1,14,1,14,3,14,286,8,14,3,14,288,8,14,1,
        15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,297,8,15,1,15,1,15,1,15,1,
        15,1,15,3,15,304,8,15,1,15,1,15,1,15,1,15,1,15,3,15,311,8,15,1,15,
        5,15,314,8,15,10,15,12,15,317,9,15,1,16,1,16,1,16,1,16,1,16,1,16,
        1,16,1,16,3,16,327,8,16,1,17,1,17,3,17,331,8,17,1,17,1,17,3,17,335,
        8,17,1,18,1,18,4,18,339,8,18,11,18,12,18,340,1,19,1,19,5,19,345,
        8,19,10,19,12,19,348,9,19,1,19,3,19,351,8,19,1,19,3,19,354,8,19,
        1,19,3,19,357,8,19,1,19,3,19,360,8,19,1,19,1,19,1,20,1,20,3,20,366,
        8,20,1,20,5,20,369,8,20,10,20,12,20,372,9,20,1,20,3,20,375,8,20,
        1,20,3,20,378,8,20,1,20,3,20,381,8,20,1,20,3,20,384,8,20,1,21,1,
        21,3,21,388,8,21,1,21,1,21,1,22,1,22,1,22,5,22,395,8,22,10,22,12,
        22,398,9,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,25,1,25,1,25,1,
        26,1,26,1,26,1,26,5,26,414,8,26,10,26,12,26,417,9,26,1,26,5,26,420,
        8,26,10,26,12,26,423,9,26,1,27,1,27,1,27,1,27,1,27,5,27,430,8,27,
        10,27,12,27,433,9,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
        1,27,5,27,445,8,27,10,27,12,27,448,9,27,1,27,1,27,3,27,452,8,27,
        1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,5,27,462,8,27,10,27,12,27,
        465,9,27,1,27,1,27,3,27,469,8,27,1,28,1,28,1,28,1,28,5,28,475,8,
        28,10,28,12,28,478,9,28,3,28,480,8,28,1,28,1,28,3,28,484,8,28,1,
        29,1,29,1,29,3,29,489,8,29,1,29,1,29,1,29,1,29,1,29,5,29,496,8,29,
        10,29,12,29,499,9,29,3,29,501,8,29,1,29,1,29,1,29,3,29,506,8,29,
        1,29,1,29,1,29,5,29,511,8,29,10,29,12,29,514,9,29,3,29,516,8,29,
        1,30,1,30,1,31,1,31,5,31,522,8,31,10,31,12,31,525,9,31,1,32,1,32,
        1,32,1,32,3,32,531,8,32,1,32,1,32,1,32,1,32,1,32,3,32,538,8,32,1,
        33,3,33,541,8,33,1,33,1,33,1,33,3,33,546,8,33,1,33,3,33,549,8,33,
        1,33,1,33,1,33,3,33,554,8,33,1,33,1,33,3,33,558,8,33,1,33,3,33,561,
        8,33,1,33,3,33,564,8,33,1,34,1,34,1,34,1,34,3,34,570,8,34,1,35,1,
        35,1,35,1,35,1,36,1,36,1,36,5,36,579,8,36,10,36,12,36,582,9,36,1,
        37,1,37,1,37,1,37,5,37,588,8,37,10,37,12,37,591,9,37,1,37,1,37,1,
        38,1,38,3,38,597,8,38,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,
        39,1,39,1,39,1,39,1,39,1,39,3,39,613,8,39,1,40,1,40,1,40,1,40,1,
        40,5,40,620,8,40,10,40,12,40,623,9,40,3,40,625,8,40,1,40,1,40,1,
        40,1,41,3,41,631,8,41,1,41,1,41,3,41,635,8,41,3,41,637,8,41,1,42,
        1,42,1,42,5,42,642,8,42,10,42,12,42,645,9,42,1,43,1,43,1,43,5,43,
        650,8,43,10,43,12,43,653,9,43,1,44,1,44,1,44,3,44,658,8,44,1,44,
        1,44,1,45,1,45,1,45,3,45,665,8,45,1,45,1,45,1,46,1,46,3,46,671,8,
        46,1,46,1,46,3,46,675,8,46,3,46,677,8,46,1,47,1,47,1,47,5,47,682,
        8,47,10,47,12,47,685,9,47,1,48,1,48,1,49,1,49,1,49,1,49,1,49,1,49,
        1,49,1,49,1,49,1,49,3,49,699,8,49,3,49,701,8,49,1,49,1,49,1,49,1,
        49,1,49,1,49,5,49,709,8,49,10,49,12,49,712,9,49,1,50,3,50,715,8,
        50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,723,8,50,1,50,1,50,1,50,1,
        50,1,50,5,50,730,8,50,10,50,12,50,733,9,50,1,50,1,50,1,50,3,50,738,
        8,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,746,8,50,1,50,1,50,1,50,
        3,50,751,8,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,5,50,761,8,
        50,10,50,12,50,764,9,50,1,50,1,50,3,50,768,8,50,1,50,3,50,771,8,
        50,1,50,1,50,1,50,1,50,3,50,777,8,50,1,50,1,50,3,50,781,8,50,1,50,
        1,50,1,50,3,50,786,8,50,1,50,1,50,1,50,3,50,791,8,50,1,50,1,50,1,
        50,3,50,796,8,50,1,51,1,51,1,51,1,51,3,51,802,8,51,1,51,1,51,1,51,
        1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,
        1,51,1,51,1,51,5,51,823,8,51,10,51,12,51,826,9,51,1,52,1,52,1,52,
        1,52,4,52,832,8,52,11,52,12,52,833,1,52,1,52,3,52,838,8,52,1,52,
        1,52,1,52,1,52,1,52,4,52,845,8,52,11,52,12,52,846,1,52,1,52,3,52,
        851,8,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,5,52,867,8,52,10,52,12,52,870,9,52,3,52,872,8,52,
        1,52,1,52,1,52,1,52,1,52,1,52,3,52,880,8,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,3,52,889,8,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,4,52,
        910,8,52,11,52,12,52,911,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,3,52,923,8,52,1,52,1,52,1,52,5,52,928,8,52,10,52,12,52,931,
        9,52,3,52,933,8,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,3,52,942,8,
        52,1,52,1,52,3,52,946,8,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,
        52,4,52,956,8,52,11,52,12,52,957,1,52,1,52,1,52,1,52,1,52,1,52,1,
        52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,
        52,1,52,1,52,1,52,3,52,983,8,52,1,52,1,52,1,52,1,52,1,52,3,52,990,
        8,52,1,52,3,52,993,8,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        1,52,1,52,1,52,1,52,1,52,3,52,1008,8,52,1,52,1,52,3,52,1012,8,52,
        1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,5,52,1022,8,52,10,52,12,
        52,1025,9,52,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,4,53,1035,8,
        53,11,53,12,53,1036,3,53,1039,8,53,1,54,1,54,1,55,1,55,1,56,1,56,
        1,57,1,57,1,58,1,58,1,58,3,58,1052,8,58,1,59,1,59,3,59,1056,8,59,
        1,60,1,60,1,60,4,60,1061,8,60,11,60,12,60,1062,1,61,1,61,1,61,3,
        61,1068,8,61,1,62,1,62,1,62,1,62,1,62,1,63,3,63,1076,8,63,1,63,1,
        63,3,63,1080,8,63,1,64,1,64,1,64,1,64,1,64,1,64,1,64,3,64,1089,8,
        64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
        65,1,65,1,65,3,65,1106,8,65,1,65,1,65,3,65,1110,8,65,1,65,1,65,1,
        65,1,65,1,65,5,65,1117,8,65,10,65,12,65,1120,9,65,1,65,3,65,1123,
        8,65,3,65,1125,8,65,1,66,1,66,1,66,5,66,1130,8,66,10,66,12,66,1133,
        9,66,1,67,1,67,1,67,1,67,1,67,3,67,1140,8,67,1,68,1,68,1,68,1,68,
        1,68,1,69,1,69,1,69,1,69,5,69,1151,8,69,10,69,12,69,1154,9,69,1,
        70,1,70,1,70,1,70,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,
        71,1,71,5,71,1171,8,71,10,71,12,71,1174,9,71,3,71,1176,8,71,1,71,
        1,71,1,71,1,71,1,71,5,71,1183,8,71,10,71,12,71,1186,9,71,3,71,1188,
        8,71,1,71,3,71,1191,8,71,1,71,3,71,1194,8,71,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,
        1212,8,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,1221,8,73,1,74,
        1,74,1,74,5,74,1226,8,74,10,74,12,74,1229,9,74,1,75,1,75,1,75,1,
        75,3,75,1235,8,75,1,76,1,76,1,76,5,76,1240,8,76,10,76,12,76,1243,
        9,76,1,77,1,77,1,77,1,78,1,78,4,78,1250,8,78,11,78,12,78,1251,1,
        78,3,78,1255,8,78,1,79,1,79,1,79,3,79,1260,8,79,1,80,1,80,1,80,1,
        80,1,80,1,80,3,80,1268,8,80,1,81,1,81,1,82,1,82,3,82,1274,8,82,1,
        82,1,82,1,82,3,82,1279,8,82,1,82,1,82,1,82,3,82,1284,8,82,1,82,1,
        82,3,82,1288,8,82,1,82,1,82,3,82,1292,8,82,1,82,1,82,3,82,1296,8,
        82,1,82,1,82,3,82,1300,8,82,1,82,1,82,3,82,1304,8,82,1,82,1,82,3,
        82,1308,8,82,1,82,3,82,1311,8,82,1,83,1,83,1,84,1,84,1,85,1,85,1,
        85,0,4,30,98,102,104,86,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,
        30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,
        74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
        114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,
        146,148,150,152,154,156,158,160,162,164,166,168,170,0,29,3,0,60,
        60,147,147,202,202,4,0,79,79,118,118,211,211,245,245,3,0,79,79,211,
        211,245,245,2,0,21,21,67,67,2,0,92,92,125,125,2,0,12,12,72,72,3,
        0,12,12,17,17,215,215,3,0,87,87,239,239,247,247,2,0,270,271,276,
        276,1,0,272,275,2,0,270,271,279,279,2,0,55,55,57,57,1,0,223,224,
        2,0,2,2,98,98,2,0,2,2,94,94,3,0,25,25,128,128,234,234,1,0,262,269,
        1,0,270,280,4,0,15,15,111,111,151,151,159,159,2,0,87,87,239,239,
        1,0,270,271,2,0,285,285,287,287,2,0,73,73,168,168,2,0,160,160,216,
        216,2,0,93,93,175,175,1,0,286,287,51,0,10,11,13,14,18,19,21,22,24,
        24,26,30,33,33,35,38,40,40,42,48,50,50,53,54,59,61,63,71,73,74,78,
        78,80,86,89,89,91,93,96,97,100,102,105,105,108,110,112,113,115,117,
        119,119,122,122,124,127,130,143,146,148,150,150,153,154,157,158,
        161,161,163,164,166,175,177,185,187,193,195,202,206,208,210,210,
        212,214,216,224,226,230,233,233,235,240,242,244,248,251,254,256,
        259,259,275,275,15,0,16,16,52,52,79,79,99,99,114,114,118,118,123,
        123,129,129,149,149,155,155,194,194,205,205,211,211,245,245,253,
        253,17,0,10,15,17,51,53,78,80,98,100,113,115,117,119,122,124,128,
        130,148,150,154,156,193,195,204,206,210,212,244,246,252,254,261,
        275,275,1471,0,172,1,0,0,0,2,181,1,0,0,0,4,184,1,0,0,0,6,187,1,0,
        0,0,8,190,1,0,0,0,10,193,1,0,0,0,12,200,1,0,0,0,14,203,1,0,0,0,16,
        208,1,0,0,0,18,210,1,0,0,0,20,219,1,0,0,0,22,230,1,0,0,0,24,241,
        1,0,0,0,26,252,1,0,0,0,28,265,1,0,0,0,30,289,1,0,0,0,32,326,1,0,
        0,0,34,328,1,0,0,0,36,336,1,0,0,0,38,342,1,0,0,0,40,363,1,0,0,0,
        42,385,1,0,0,0,44,391,1,0,0,0,46,399,1,0,0,0,48,403,1,0,0,0,50,406,
        1,0,0,0,52,409,1,0,0,0,54,468,1,0,0,0,56,483,1,0,0,0,58,485,1,0,
        0,0,60,517,1,0,0,0,62,519,1,0,0,0,64,537,1,0,0,0,66,563,1,0,0,0,
        68,569,1,0,0,0,70,571,1,0,0,0,72,575,1,0,0,0,74,583,1,0,0,0,76,594,
        1,0,0,0,78,612,1,0,0,0,80,614,1,0,0,0,82,636,1,0,0,0,84,638,1,0,
        0,0,86,646,1,0,0,0,88,657,1,0,0,0,90,664,1,0,0,0,92,668,1,0,0,0,
        94,678,1,0,0,0,96,686,1,0,0,0,98,700,1,0,0,0,100,795,1,0,0,0,102,
        801,1,0,0,0,104,1011,1,0,0,0,106,1038,1,0,0,0,108,1040,1,0,0,0,110,
        1042,1,0,0,0,112,1044,1,0,0,0,114,1046,1,0,0,0,116,1048,1,0,0,0,
        118,1053,1,0,0,0,120,1060,1,0,0,0,122,1064,1,0,0,0,124,1069,1,0,
        0,0,126,1079,1,0,0,0,128,1088,1,0,0,0,130,1124,1,0,0,0,132,1126,
        1,0,0,0,134,1134,1,0,0,0,136,1141,1,0,0,0,138,1146,1,0,0,0,140,1155,
        1,0,0,0,142,1193,1,0,0,0,144,1211,1,0,0,0,146,1220,1,0,0,0,148,1222,
        1,0,0,0,150,1234,1,0,0,0,152,1236,1,0,0,0,154,1244,1,0,0,0,156,1254,
        1,0,0,0,158,1259,1,0,0,0,160,1267,1,0,0,0,162,1269,1,0,0,0,164,1310,
        1,0,0,0,166,1312,1,0,0,0,168,1314,1,0,0,0,170,1316,1,0,0,0,172,176,
        3,12,6,0,173,175,5,1,0,0,174,173,1,0,0,0,175,178,1,0,0,0,176,174,
        1,0,0,0,176,177,1,0,0,0,177,179,1,0,0,0,178,176,1,0,0,0,179,180,
        5,0,0,1,180,1,1,0,0,0,181,182,3,92,46,0,182,183,5,0,0,1,183,3,1,
        0,0,0,184,185,3,88,44,0,185,186,5,0,0,1,186,5,1,0,0,0,187,188,3,
        86,43,0,188,189,5,0,0,1,189,7,1,0,0,0,190,191,3,90,45,0,191,192,
        5,0,0,1,192,9,1,0,0,0,193,194,3,130,65,0,194,195,5,0,0,1,195,11,
        1,0,0,0,196,201,3,14,7,0,197,199,3,18,9,0,198,197,1,0,0,0,198,199,
        1,0,0,0,199,201,1,0,0,0,200,196,1,0,0,0,200,198,1,0,0,0,201,13,1,
        0,0,0,202,204,3,18,9,0,203,202,1,0,0,0,203,204,1,0,0,0,204,205,1,
        0,0,0,205,206,3,30,15,0,206,207,3,28,14,0,207,15,1,0,0,0,208,209,
        7,0,0,0,209,17,1,0,0,0,210,211,5,260,0,0,211,216,3,20,10,0,212,213,
        5,2,0,0,213,215,3,20,10,0,214,212,1,0,0,0,215,218,1,0,0,0,216,214,
        1,0,0,0,216,217,1,0,0,0,217,19,1,0,0,0,218,216,1,0,0,0,219,221,3,
        154,77,0,220,222,3,70,35,0,221,220,1,0,0,0,221,222,1,0,0,0,222,224,
        1,0,0,0,223,225,5,20,0,0,224,223,1,0,0,0,224,225,1,0,0,0,225,226,
        1,0,0,0,226,227,5,3,0,0,227,228,3,14,7,0,228,229,5,4,0,0,229,21,
        1,0,0,0,230,231,5,3,0,0,231,236,3,106,53,0,232,233,5,2,0,0,233,235,
        3,106,53,0,234,232,1,0,0,0,235,238,1,0,0,0,236,234,1,0,0,0,236,237,
        1,0,0,0,237,239,1,0,0,0,238,236,1,0,0,0,239,240,5,4,0,0,240,23,1,
        0,0,0,241,242,5,3,0,0,242,247,3,22,11,0,243,244,5,2,0,0,244,246,
        3,22,11,0,245,243,1,0,0,0,246,249,1,0,0,0,247,245,1,0,0,0,247,248,
        1,0,0,0,248,250,1,0,0,0,249,247,1,0,0,0,250,251,5,4,0,0,251,25,1,
        0,0,0,252,253,3,158,79,0,253,254,5,281,0,0,254,27,1,0,0,0,255,256,
        5,160,0,0,256,257,5,28,0,0,257,262,3,34,17,0,258,259,5,2,0,0,259,
        261,3,34,17,0,260,258,1,0,0,0,261,264,1,0,0,0,262,260,1,0,0,0,262,
        263,1,0,0,0,263,266,1,0,0,0,264,262,1,0,0,0,265,255,1,0,0,0,265,
        266,1,0,0,0,266,277,1,0,0,0,267,268,5,216,0,0,268,269,5,28,0,0,269,
        274,3,34,17,0,270,271,5,2,0,0,271,273,3,34,17,0,272,270,1,0,0,0,
        273,276,1,0,0,0,274,272,1,0,0,0,274,275,1,0,0,0,275,278,1,0,0,0,
        276,274,1,0,0,0,277,267,1,0,0,0,277,278,1,0,0,0,278,280,1,0,0,0,
        279,281,3,138,69,0,280,279,1,0,0,0,280,281,1,0,0,0,281,287,1,0,0,
        0,282,285,5,131,0,0,283,286,5,12,0,0,284,286,3,96,48,0,285,283,1,
        0,0,0,285,284,1,0,0,0,286,288,1,0,0,0,287,282,1,0,0,0,287,288,1,
        0,0,0,288,29,1,0,0,0,289,290,6,15,-1,0,290,291,3,32,16,0,291,315,
        1,0,0,0,292,293,10,3,0,0,293,294,4,15,1,0,294,296,7,1,0,0,295,297,
        3,60,30,0,296,295,1,0,0,0,296,297,1,0,0,0,297,298,1,0,0,0,298,314,
        3,30,15,4,299,300,10,2,0,0,300,301,4,15,3,0,301,303,5,118,0,0,302,
        304,3,60,30,0,303,302,1,0,0,0,303,304,1,0,0,0,304,305,1,0,0,0,305,
        314,3,30,15,3,306,307,10,1,0,0,307,308,4,15,5,0,308,310,7,2,0,0,
        309,311,3,60,30,0,310,309,1,0,0,0,310,311,1,0,0,0,311,312,1,0,0,
        0,312,314,3,30,15,2,313,292,1,0,0,0,313,299,1,0,0,0,313,306,1,0,
        0,0,314,317,1,0,0,0,315,313,1,0,0,0,315,316,1,0,0,0,316,31,1,0,0,
        0,317,315,1,0,0,0,318,327,3,40,20,0,319,327,3,36,18,0,320,321,5,
        225,0,0,321,327,3,86,43,0,322,323,5,3,0,0,323,324,3,14,7,0,324,325,
        5,4,0,0,325,327,1,0,0,0,326,318,1,0,0,0,326,319,1,0,0,0,326,320,
        1,0,0,0,326,322,1,0,0,0,327,33,1,0,0,0,328,330,3,96,48,0,329,331,
        7,3,0,0,330,329,1,0,0,0,330,331,1,0,0,0,331,334,1,0,0,0,332,333,
        5,153,0,0,333,335,7,4,0,0,334,332,1,0,0,0,334,335,1,0,0,0,335,35,
        1,0,0,0,336,338,3,52,26,0,337,339,3,38,19,0,338,337,1,0,0,0,339,
        340,1,0,0,0,340,338,1,0,0,0,340,341,1,0,0,0,341,37,1,0,0,0,342,346,
        3,42,21,0,343,345,3,58,29,0,344,343,1,0,0,0,345,348,1,0,0,0,346,
        344,1,0,0,0,346,347,1,0,0,0,347,350,1,0,0,0,348,346,1,0,0,0,349,
        351,3,48,24,0,350,349,1,0,0,0,350,351,1,0,0,0,351,353,1,0,0,0,352,
        354,3,54,27,0,353,352,1,0,0,0,353,354,1,0,0,0,354,356,1,0,0,0,355,
        357,3,50,25,0,356,355,1,0,0,0,356,357,1,0,0,0,357,359,1,0,0,0,358,
        360,3,138,69,0,359,358,1,0,0,0,359,360,1,0,0,0,360,361,1,0,0,0,361,
        362,3,28,14,0,362,39,1,0,0,0,363,365,3,42,21,0,364,366,3,52,26,0,
        365,364,1,0,0,0,365,366,1,0,0,0,366,370,1,0,0,0,367,369,3,58,29,
        0,368,367,1,0,0,0,369,372,1,0,0,0,370,368,1,0,0,0,370,371,1,0,0,
        0,371,374,1,0,0,0,372,370,1,0,0,0,373,375,3,48,24,0,374,373,1,0,
        0,0,374,375,1,0,0,0,375,377,1,0,0,0,376,378,3,54,27,0,377,376,1,
        0,0,0,377,378,1,0,0,0,378,380,1,0,0,0,379,381,3,50,25,0,380,379,
        1,0,0,0,380,381,1,0,0,0,381,383,1,0,0,0,382,384,3,138,69,0,383,382,
        1,0,0,0,383,384,1,0,0,0,384,41,1,0,0,0,385,387,5,204,0,0,386,388,
        3,60,30,0,387,386,1,0,0,0,387,388,1,0,0,0,388,389,1,0,0,0,389,390,
        3,94,47,0,390,43,1,0,0,0,391,396,3,46,23,0,392,393,5,2,0,0,393,395,
        3,46,23,0,394,392,1,0,0,0,395,398,1,0,0,0,396,394,1,0,0,0,396,397,
        1,0,0,0,397,45,1,0,0,0,398,396,1,0,0,0,399,400,3,86,43,0,400,401,
        5,262,0,0,401,402,3,96,48,0,402,47,1,0,0,0,403,404,5,258,0,0,404,
        405,3,98,49,0,405,49,1,0,0,0,406,407,5,106,0,0,407,408,3,98,49,0,
        408,51,1,0,0,0,409,410,5,98,0,0,410,415,3,62,31,0,411,412,5,2,0,
        0,412,414,3,62,31,0,413,411,1,0,0,0,414,417,1,0,0,0,415,413,1,0,
        0,0,415,416,1,0,0,0,416,421,1,0,0,0,417,415,1,0,0,0,418,420,3,58,
        29,0,419,418,1,0,0,0,420,423,1,0,0,0,421,419,1,0,0,0,421,422,1,0,
        0,0,422,53,1,0,0,0,423,421,1,0,0,0,424,425,5,104,0,0,425,426,5,28,
        0,0,426,431,3,96,48,0,427,428,5,2,0,0,428,430,3,96,48,0,429,427,
        1,0,0,0,430,433,1,0,0,0,431,429,1,0,0,0,431,432,1,0,0,0,432,451,
        1,0,0,0,433,431,1,0,0,0,434,435,5,260,0,0,435,452,5,199,0,0,436,
        437,5,260,0,0,437,452,5,53,0,0,438,439,5,105,0,0,439,440,5,212,0,
        0,440,441,5,3,0,0,441,446,3,56,28,0,442,443,5,2,0,0,443,445,3,56,
        28,0,444,442,1,0,0,0,445,448,1,0,0,0,446,444,1,0,0,0,446,447,1,0,
        0,0,447,449,1,0,0,0,448,446,1,0,0,0,449,450,5,4,0,0,450,452,1,0,
        0,0,451,434,1,0,0,0,451,436,1,0,0,0,451,438,1,0,0,0,451,452,1,0,
        0,0,452,469,1,0,0,0,453,454,5,104,0,0,454,455,5,28,0,0,455,456,5,
        105,0,0,456,457,5,212,0,0,457,458,5,3,0,0,458,463,3,56,28,0,459,
        460,5,2,0,0,460,462,3,56,28,0,461,459,1,0,0,0,462,465,1,0,0,0,463,
        461,1,0,0,0,463,464,1,0,0,0,464,466,1,0,0,0,465,463,1,0,0,0,466,
        467,5,4,0,0,467,469,1,0,0,0,468,424,1,0,0,0,468,453,1,0,0,0,469,
        55,1,0,0,0,470,479,5,3,0,0,471,476,3,96,48,0,472,473,5,2,0,0,473,
        475,3,96,48,0,474,472,1,0,0,0,475,478,1,0,0,0,476,474,1,0,0,0,476,
        477,1,0,0,0,477,480,1,0,0,0,478,476,1,0,0,0,479,471,1,0,0,0,479,
        480,1,0,0,0,480,481,1,0,0,0,481,484,5,4,0,0,482,484,3,96,48,0,483,
        470,1,0,0,0,483,482,1,0,0,0,484,57,1,0,0,0,485,486,5,126,0,0,486,
        488,5,255,0,0,487,489,5,162,0,0,488,487,1,0,0,0,488,489,1,0,0,0,
        489,490,1,0,0,0,490,491,3,152,76,0,491,500,5,3,0,0,492,497,3,96,
        48,0,493,494,5,2,0,0,494,496,3,96,48,0,495,493,1,0,0,0,496,499,1,
        0,0,0,497,495,1,0,0,0,497,498,1,0,0,0,498,501,1,0,0,0,499,497,1,
        0,0,0,500,492,1,0,0,0,500,501,1,0,0,0,501,502,1,0,0,0,502,503,5,
        4,0,0,503,515,3,158,79,0,504,506,5,20,0,0,505,504,1,0,0,0,505,506,
        1,0,0,0,506,507,1,0,0,0,507,512,3,158,79,0,508,509,5,2,0,0,509,511,
        3,158,79,0,510,508,1,0,0,0,511,514,1,0,0,0,512,510,1,0,0,0,512,513,
        1,0,0,0,513,516,1,0,0,0,514,512,1,0,0,0,515,505,1,0,0,0,515,516,
        1,0,0,0,516,59,1,0,0,0,517,518,7,5,0,0,518,61,1,0,0,0,519,523,3,
        78,39,0,520,522,3,64,32,0,521,520,1,0,0,0,522,525,1,0,0,0,523,521,
        1,0,0,0,523,524,1,0,0,0,524,63,1,0,0,0,525,523,1,0,0,0,526,527,3,
        66,33,0,527,528,5,123,0,0,528,530,3,78,39,0,529,531,3,68,34,0,530,
        529,1,0,0,0,530,531,1,0,0,0,531,538,1,0,0,0,532,533,5,149,0,0,533,
        534,3,66,33,0,534,535,5,123,0,0,535,536,3,78,39,0,536,538,1,0,0,
        0,537,526,1,0,0,0,537,532,1,0,0,0,538,65,1,0,0,0,539,541,5,114,0,
        0,540,539,1,0,0,0,540,541,1,0,0,0,541,564,1,0,0,0,542,564,5,52,0,
        0,543,545,5,129,0,0,544,546,5,162,0,0,545,544,1,0,0,0,545,546,1,
        0,0,0,546,564,1,0,0,0,547,549,5,129,0,0,548,547,1,0,0,0,548,549,
        1,0,0,0,549,550,1,0,0,0,550,564,5,205,0,0,551,553,5,194,0,0,552,
        554,5,162,0,0,553,552,1,0,0,0,553,554,1,0,0,0,554,564,1,0,0,0,555,
        557,5,99,0,0,556,558,5,162,0,0,557,556,1,0,0,0,557,558,1,0,0,0,558,
        564,1,0,0,0,559,561,5,129,0,0,560,559,1,0,0,0,560,561,1,0,0,0,561,
        562,1,0,0,0,562,564,5,16,0,0,563,540,1,0,0,0,563,542,1,0,0,0,563,
        543,1,0,0,0,563,548,1,0,0,0,563,551,1,0,0,0,563,555,1,0,0,0,563,
        560,1,0,0,0,564,67,1,0,0,0,565,566,5,155,0,0,566,570,3,98,49,0,567,
        568,5,253,0,0,568,570,3,70,35,0,569,565,1,0,0,0,569,567,1,0,0,0,
        570,69,1,0,0,0,571,572,5,3,0,0,572,573,3,72,36,0,573,574,5,4,0,0,
        574,71,1,0,0,0,575,580,3,154,77,0,576,577,5,2,0,0,577,579,3,154,
        77,0,578,576,1,0,0,0,579,582,1,0,0,0,580,578,1,0,0,0,580,581,1,0,
        0,0,581,73,1,0,0,0,582,580,1,0,0,0,583,584,5,3,0,0,584,589,3,76,
        38,0,585,586,5,2,0,0,586,588,3,76,38,0,587,585,1,0,0,0,588,591,1,
        0,0,0,589,587,1,0,0,0,589,590,1,0,0,0,590,592,1,0,0,0,591,589,1,
        0,0,0,592,593,5,4,0,0,593,75,1,0,0,0,594,596,3,154,77,0,595,597,
        7,3,0,0,596,595,1,0,0,0,596,597,1,0,0,0,597,77,1,0,0,0,598,599,3,
        86,43,0,599,600,3,82,41,0,600,613,1,0,0,0,601,602,5,3,0,0,602,603,
        3,14,7,0,603,604,5,4,0,0,604,605,3,82,41,0,605,613,1,0,0,0,606,607,
        5,3,0,0,607,608,3,62,31,0,608,609,5,4,0,0,609,610,3,82,41,0,610,
        613,1,0,0,0,611,613,3,80,40,0,612,598,1,0,0,0,612,601,1,0,0,0,612,
        606,1,0,0,0,612,611,1,0,0,0,613,79,1,0,0,0,614,615,3,154,77,0,615,
        624,5,3,0,0,616,621,3,96,48,0,617,618,5,2,0,0,618,620,3,96,48,0,
        619,617,1,0,0,0,620,623,1,0,0,0,621,619,1,0,0,0,621,622,1,0,0,0,
        622,625,1,0,0,0,623,621,1,0,0,0,624,616,1,0,0,0,624,625,1,0,0,0,
        625,626,1,0,0,0,626,627,5,4,0,0,627,628,3,82,41,0,628,81,1,0,0,0,
        629,631,5,20,0,0,630,629,1,0,0,0,630,631,1,0,0,0,631,632,1,0,0,0,
        632,634,3,160,80,0,633,635,3,70,35,0,634,633,1,0,0,0,634,635,1,0,
        0,0,635,637,1,0,0,0,636,630,1,0,0,0,636,637,1,0,0,0,637,83,1,0,0,
        0,638,643,3,86,43,0,639,640,5,2,0,0,640,642,3,86,43,0,641,639,1,
        0,0,0,642,645,1,0,0,0,643,641,1,0,0,0,643,644,1,0,0,0,644,85,1,0,
        0,0,645,643,1,0,0,0,646,651,3,154,77,0,647,648,5,5,0,0,648,650,3,
        154,77,0,649,647,1,0,0,0,650,653,1,0,0,0,651,649,1,0,0,0,651,652,
        1,0,0,0,652,87,1,0,0,0,653,651,1,0,0,0,654,655,3,154,77,0,655,656,
        5,5,0,0,656,658,1,0,0,0,657,654,1,0,0,0,657,658,1,0,0,0,658,659,
        1,0,0,0,659,660,3,154,77,0,660,89,1,0,0,0,661,662,3,154,77,0,662,
        663,5,5,0,0,663,665,1,0,0,0,664,661,1,0,0,0,664,665,1,0,0,0,665,
        666,1,0,0,0,666,667,3,154,77,0,667,91,1,0,0,0,668,676,3,96,48,0,
        669,671,5,20,0,0,670,669,1,0,0,0,670,671,1,0,0,0,671,674,1,0,0,0,
        672,675,3,154,77,0,673,675,3,70,35,0,674,672,1,0,0,0,674,673,1,0,
        0,0,675,677,1,0,0,0,676,670,1,0,0,0,676,677,1,0,0,0,677,93,1,0,0,
        0,678,683,3,92,46,0,679,680,5,2,0,0,680,682,3,92,46,0,681,679,1,
        0,0,0,682,685,1,0,0,0,683,681,1,0,0,0,683,684,1,0,0,0,684,95,1,0,
        0,0,685,683,1,0,0,0,686,687,3,98,49,0,687,97,1,0,0,0,688,689,6,49,
        -1,0,689,690,5,151,0,0,690,701,3,98,49,5,691,692,5,81,0,0,692,693,
        5,3,0,0,693,694,3,14,7,0,694,695,5,4,0,0,695,701,1,0,0,0,696,698,
        3,102,51,0,697,699,3,100,50,0,698,697,1,0,0,0,698,699,1,0,0,0,699,
        701,1,0,0,0,700,688,1,0,0,0,700,691,1,0,0,0,700,696,1,0,0,0,701,
        710,1,0,0,0,702,703,10,2,0,0,703,704,5,15,0,0,704,709,3,98,49,3,
        705,706,10,1,0,0,706,707,5,159,0,0,707,709,3,98,49,2,708,702,1,0,
        0,0,708,705,1,0,0,0,709,712,1,0,0,0,710,708,1,0,0,0,710,711,1,0,
        0,0,711,99,1,0,0,0,712,710,1,0,0,0,713,715,5,151,0,0,714,713,1,0,
        0,0,714,715,1,0,0,0,715,716,1,0,0,0,716,717,5,24,0,0,717,718,3,102,
        51,0,718,719,5,15,0,0,719,720,3,102,51,0,720,796,1,0,0,0,721,723,
        5,151,0,0,722,721,1,0,0,0,722,723,1,0,0,0,723,724,1,0,0,0,724,725,
        5,111,0,0,725,726,5,3,0,0,726,731,3,96,48,0,727,728,5,2,0,0,728,
        730,3,96,48,0,729,727,1,0,0,0,730,733,1,0,0,0,731,729,1,0,0,0,731,
        732,1,0,0,0,732,734,1,0,0,0,733,731,1,0,0,0,734,735,5,4,0,0,735,
        796,1,0,0,0,736,738,5,151,0,0,737,736,1,0,0,0,737,738,1,0,0,0,738,
        739,1,0,0,0,739,740,5,111,0,0,740,741,5,3,0,0,741,742,3,14,7,0,742,
        743,5,4,0,0,743,796,1,0,0,0,744,746,5,151,0,0,745,744,1,0,0,0,745,
        746,1,0,0,0,746,747,1,0,0,0,747,748,5,195,0,0,748,796,3,102,51,0,
        749,751,5,151,0,0,750,749,1,0,0,0,750,751,1,0,0,0,751,752,1,0,0,
        0,752,753,5,130,0,0,753,767,7,6,0,0,754,755,5,3,0,0,755,768,5,4,
        0,0,756,757,5,3,0,0,757,762,3,96,48,0,758,759,5,2,0,0,759,761,3,
        96,48,0,760,758,1,0,0,0,761,764,1,0,0,0,762,760,1,0,0,0,762,763,
        1,0,0,0,763,765,1,0,0,0,764,762,1,0,0,0,765,766,5,4,0,0,766,768,
        1,0,0,0,767,754,1,0,0,0,767,756,1,0,0,0,768,796,1,0,0,0,769,771,
        5,151,0,0,770,769,1,0,0,0,770,771,1,0,0,0,771,772,1,0,0,0,772,773,
        5,130,0,0,773,776,3,102,51,0,774,775,5,77,0,0,775,777,5,281,0,0,
        776,774,1,0,0,0,776,777,1,0,0,0,777,796,1,0,0,0,778,780,5,121,0,
        0,779,781,5,151,0,0,780,779,1,0,0,0,780,781,1,0,0,0,781,782,1,0,
        0,0,782,796,5,152,0,0,783,785,5,121,0,0,784,786,5,151,0,0,785,784,
        1,0,0,0,785,786,1,0,0,0,786,787,1,0,0,0,787,796,7,7,0,0,788,790,
        5,121,0,0,789,791,5,151,0,0,790,789,1,0,0,0,790,791,1,0,0,0,791,
        792,1,0,0,0,792,793,5,72,0,0,793,794,5,98,0,0,794,796,3,102,51,0,
        795,714,1,0,0,0,795,722,1,0,0,0,795,737,1,0,0,0,795,745,1,0,0,0,
        795,750,1,0,0,0,795,770,1,0,0,0,795,778,1,0,0,0,795,783,1,0,0,0,
        795,788,1,0,0,0,796,101,1,0,0,0,797,798,6,51,-1,0,798,802,3,104,
        52,0,799,800,7,8,0,0,800,802,3,102,51,7,801,797,1,0,0,0,801,799,
        1,0,0,0,802,824,1,0,0,0,803,804,10,6,0,0,804,805,7,9,0,0,805,823,
        3,102,51,7,806,807,10,5,0,0,807,808,7,10,0,0,808,823,3,102,51,6,
        809,810,10,4,0,0,810,811,5,277,0,0,811,823,3,102,51,5,812,813,10,
        3,0,0,813,814,5,280,0,0,814,823,3,102,51,4,815,816,10,2,0,0,816,
        817,5,278,0,0,817,823,3,102,51,3,818,819,10,1,0,0,819,820,3,108,
        54,0,820,821,3,102,51,2,821,823,1,0,0,0,822,803,1,0,0,0,822,806,
        1,0,0,0,822,809,1,0,0,0,822,812,1,0,0,0,822,815,1,0,0,0,822,818,
        1,0,0,0,823,826,1,0,0,0,824,822,1,0,0,0,824,825,1,0,0,0,825,103,
        1,0,0,0,826,824,1,0,0,0,827,828,6,52,-1,0,828,1012,7,11,0,0,829,
        831,5,31,0,0,830,832,3,136,68,0,831,830,1,0,0,0,832,833,1,0,0,0,
        833,831,1,0,0,0,833,834,1,0,0,0,834,837,1,0,0,0,835,836,5,75,0,0,
        836,838,3,96,48,0,837,835,1,0,0,0,837,838,1,0,0,0,838,839,1,0,0,
        0,839,840,5,76,0,0,840,1012,1,0,0,0,841,842,5,31,0,0,842,844,3,96,
        48,0,843,845,3,136,68,0,844,843,1,0,0,0,845,846,1,0,0,0,846,844,
        1,0,0,0,846,847,1,0,0,0,847,850,1,0,0,0,848,849,5,75,0,0,849,851,
        3,96,48,0,850,848,1,0,0,0,850,851,1,0,0,0,851,852,1,0,0,0,852,853,
        5,76,0,0,853,1012,1,0,0,0,854,855,5,32,0,0,855,856,5,3,0,0,856,857,
        3,96,48,0,857,858,5,20,0,0,858,859,3,130,65,0,859,860,5,4,0,0,860,
        1012,1,0,0,0,861,862,5,222,0,0,862,871,5,3,0,0,863,868,3,92,46,0,
        864,865,5,2,0,0,865,867,3,92,46,0,866,864,1,0,0,0,867,870,1,0,0,
        0,868,866,1,0,0,0,868,869,1,0,0,0,869,872,1,0,0,0,870,868,1,0,0,
        0,871,863,1,0,0,0,871,872,1,0,0,0,872,873,1,0,0,0,873,1012,5,4,0,
        0,874,875,5,92,0,0,875,876,5,3,0,0,876,879,3,96,48,0,877,878,5,109,
        0,0,878,880,5,153,0,0,879,877,1,0,0,0,879,880,1,0,0,0,880,881,1,
        0,0,0,881,882,5,4,0,0,882,1012,1,0,0,0,883,884,5,125,0,0,884,885,
        5,3,0,0,885,888,3,96,48,0,886,887,5,109,0,0,887,889,5,153,0,0,888,
        886,1,0,0,0,888,889,1,0,0,0,889,890,1,0,0,0,890,891,5,4,0,0,891,
        1012,1,0,0,0,892,893,5,174,0,0,893,894,5,3,0,0,894,895,3,102,51,
        0,895,896,5,111,0,0,896,897,3,102,51,0,897,898,5,4,0,0,898,1012,
        1,0,0,0,899,1012,3,106,53,0,900,1012,5,272,0,0,901,902,3,152,76,
        0,902,903,5,5,0,0,903,904,5,272,0,0,904,1012,1,0,0,0,905,906,5,3,
        0,0,906,909,3,92,46,0,907,908,5,2,0,0,908,910,3,92,46,0,909,907,
        1,0,0,0,910,911,1,0,0,0,911,909,1,0,0,0,911,912,1,0,0,0,912,913,
        1,0,0,0,913,914,5,4,0,0,914,1012,1,0,0,0,915,916,5,3,0,0,916,917,
        3,14,7,0,917,918,5,4,0,0,918,1012,1,0,0,0,919,920,3,150,75,0,920,
        932,5,3,0,0,921,923,3,60,30,0,922,921,1,0,0,0,922,923,1,0,0,0,923,
        924,1,0,0,0,924,929,3,96,48,0,925,926,5,2,0,0,926,928,3,96,48,0,
        927,925,1,0,0,0,928,931,1,0,0,0,929,927,1,0,0,0,929,930,1,0,0,0,
        930,933,1,0,0,0,931,929,1,0,0,0,932,922,1,0,0,0,932,933,1,0,0,0,
        933,934,1,0,0,0,934,941,5,4,0,0,935,936,5,90,0,0,936,937,5,3,0,0,
        937,938,5,258,0,0,938,939,3,98,49,0,939,940,5,4,0,0,940,942,1,0,
        0,0,941,935,1,0,0,0,941,942,1,0,0,0,942,945,1,0,0,0,943,944,5,164,
        0,0,944,946,3,142,71,0,945,943,1,0,0,0,945,946,1,0,0,0,946,1012,
        1,0,0,0,947,948,3,158,79,0,948,949,5,6,0,0,949,950,3,96,48,0,950,
        1012,1,0,0,0,951,952,5,3,0,0,952,955,3,158,79,0,953,954,5,2,0,0,
        954,956,3,158,79,0,955,953,1,0,0,0,956,957,1,0,0,0,957,955,1,0,0,
        0,957,958,1,0,0,0,958,959,1,0,0,0,959,960,5,4,0,0,960,961,5,6,0,
        0,961,962,3,96,48,0,962,1012,1,0,0,0,963,1012,3,158,79,0,964,965,
        5,3,0,0,965,966,3,96,48,0,966,967,5,4,0,0,967,1012,1,0,0,0,968,969,
        5,86,0,0,969,970,5,3,0,0,970,971,3,158,79,0,971,972,5,98,0,0,972,
        973,3,102,51,0,973,974,5,4,0,0,974,1012,1,0,0,0,975,976,7,12,0,0,
        976,977,5,3,0,0,977,978,3,102,51,0,978,979,7,13,0,0,979,982,3,102,
        51,0,980,981,7,14,0,0,981,983,3,102,51,0,982,980,1,0,0,0,982,983,
        1,0,0,0,983,984,1,0,0,0,984,985,5,4,0,0,985,1012,1,0,0,0,986,987,
        5,238,0,0,987,989,5,3,0,0,988,990,7,15,0,0,989,988,1,0,0,0,989,990,
        1,0,0,0,990,992,1,0,0,0,991,993,3,102,51,0,992,991,1,0,0,0,992,993,
        1,0,0,0,993,994,1,0,0,0,994,995,5,98,0,0,995,996,3,102,51,0,996,
        997,5,4,0,0,997,1012,1,0,0,0,998,999,5,166,0,0,999,1000,5,3,0,0,
        1000,1001,3,102,51,0,1001,1002,5,173,0,0,1002,1003,3,102,51,0,1003,
        1004,5,98,0,0,1004,1007,3,102,51,0,1005,1006,5,94,0,0,1006,1008,
        3,102,51,0,1007,1005,1,0,0,0,1007,1008,1,0,0,0,1008,1009,1,0,0,0,
        1009,1010,5,4,0,0,1010,1012,1,0,0,0,1011,827,1,0,0,0,1011,829,1,
        0,0,0,1011,841,1,0,0,0,1011,854,1,0,0,0,1011,861,1,0,0,0,1011,874,
        1,0,0,0,1011,883,1,0,0,0,1011,892,1,0,0,0,1011,899,1,0,0,0,1011,
        900,1,0,0,0,1011,901,1,0,0,0,1011,905,1,0,0,0,1011,915,1,0,0,0,1011,
        919,1,0,0,0,1011,947,1,0,0,0,1011,951,1,0,0,0,1011,963,1,0,0,0,1011,
        964,1,0,0,0,1011,968,1,0,0,0,1011,975,1,0,0,0,1011,986,1,0,0,0,1011,
        998,1,0,0,0,1012,1023,1,0,0,0,1013,1014,10,8,0,0,1014,1015,5,7,0,
        0,1015,1016,3,102,51,0,1016,1017,5,8,0,0,1017,1022,1,0,0,0,1018,
        1019,10,6,0,0,1019,1020,5,5,0,0,1020,1022,3,158,79,0,1021,1013,1,
        0,0,0,1021,1018,1,0,0,0,1022,1025,1,0,0,0,1023,1021,1,0,0,0,1023,
        1024,1,0,0,0,1024,105,1,0,0,0,1025,1023,1,0,0,0,1026,1039,5,152,
        0,0,1027,1039,3,116,58,0,1028,1029,3,158,79,0,1029,1030,5,281,0,
        0,1030,1039,1,0,0,0,1031,1039,3,164,82,0,1032,1039,3,114,57,0,1033,
        1035,5,281,0,0,1034,1033,1,0,0,0,1035,1036,1,0,0,0,1036,1034,1,0,
        0,0,1036,1037,1,0,0,0,1037,1039,1,0,0,0,1038,1026,1,0,0,0,1038,1027,
        1,0,0,0,1038,1028,1,0,0,0,1038,1031,1,0,0,0,1038,1032,1,0,0,0,1038,
        1034,1,0,0,0,1039,107,1,0,0,0,1040,1041,7,16,0,0,1041,109,1,0,0,
        0,1042,1043,7,17,0,0,1043,111,1,0,0,0,1044,1045,7,18,0,0,1045,113,
        1,0,0,0,1046,1047,7,19,0,0,1047,115,1,0,0,0,1048,1051,5,119,0,0,
        1049,1052,3,118,59,0,1050,1052,3,122,61,0,1051,1049,1,0,0,0,1051,
        1050,1,0,0,0,1051,1052,1,0,0,0,1052,117,1,0,0,0,1053,1055,3,120,
        60,0,1054,1056,3,124,62,0,1055,1054,1,0,0,0,1055,1056,1,0,0,0,1056,
        119,1,0,0,0,1057,1058,3,126,63,0,1058,1059,3,128,64,0,1059,1061,
        1,0,0,0,1060,1057,1,0,0,0,1061,1062,1,0,0,0,1062,1060,1,0,0,0,1062,
        1063,1,0,0,0,1063,121,1,0,0,0,1064,1067,3,124,62,0,1065,1068,3,120,
        60,0,1066,1068,3,124,62,0,1067,1065,1,0,0,0,1067,1066,1,0,0,0,1067,
        1068,1,0,0,0,1068,123,1,0,0,0,1069,1070,3,126,63,0,1070,1071,3,128,
        64,0,1071,1072,5,232,0,0,1072,1073,3,128,64,0,1073,125,1,0,0,0,1074,
        1076,7,20,0,0,1075,1074,1,0,0,0,1075,1076,1,0,0,0,1076,1077,1,0,
        0,0,1077,1080,7,21,0,0,1078,1080,5,281,0,0,1079,1075,1,0,0,0,1079,
        1078,1,0,0,0,1080,127,1,0,0,0,1081,1089,5,62,0,0,1082,1089,5,107,
        0,0,1083,1089,5,144,0,0,1084,1089,5,145,0,0,1085,1089,5,203,0,0,
        1086,1089,5,261,0,0,1087,1089,3,158,79,0,1088,1081,1,0,0,0,1088,
        1082,1,0,0,0,1088,1083,1,0,0,0,1088,1084,1,0,0,0,1088,1085,1,0,0,
        0,1088,1086,1,0,0,0,1088,1087,1,0,0,0,1089,129,1,0,0,0,1090,1091,
        5,19,0,0,1091,1092,5,266,0,0,1092,1093,3,130,65,0,1093,1094,5,268,
        0,0,1094,1125,1,0,0,0,1095,1096,5,141,0,0,1096,1097,5,266,0,0,1097,
        1098,3,130,65,0,1098,1099,5,2,0,0,1099,1100,3,130,65,0,1100,1101,
        5,268,0,0,1101,1125,1,0,0,0,1102,1109,5,222,0,0,1103,1105,5,266,
        0,0,1104,1106,3,132,66,0,1105,1104,1,0,0,0,1105,1106,1,0,0,0,1106,
        1107,1,0,0,0,1107,1110,5,268,0,0,1108,1110,5,264,0,0,1109,1103,1,
        0,0,0,1109,1108,1,0,0,0,1110,1125,1,0,0,0,1111,1122,3,158,79,0,1112,
        1113,5,3,0,0,1113,1118,5,285,0,0,1114,1115,5,2,0,0,1115,1117,5,285,
        0,0,1116,1114,1,0,0,0,1117,1120,1,0,0,0,1118,1116,1,0,0,0,1118,1119,
        1,0,0,0,1119,1121,1,0,0,0,1120,1118,1,0,0,0,1121,1123,5,4,0,0,1122,
        1112,1,0,0,0,1122,1123,1,0,0,0,1123,1125,1,0,0,0,1124,1090,1,0,0,
        0,1124,1095,1,0,0,0,1124,1102,1,0,0,0,1124,1111,1,0,0,0,1125,131,
        1,0,0,0,1126,1131,3,134,67,0,1127,1128,5,2,0,0,1128,1130,3,134,67,
        0,1129,1127,1,0,0,0,1130,1133,1,0,0,0,1131,1129,1,0,0,0,1131,1132,
        1,0,0,0,1132,133,1,0,0,0,1133,1131,1,0,0,0,1134,1135,3,158,79,0,
        1135,1136,5,9,0,0,1136,1139,3,130,65,0,1137,1138,5,151,0,0,1138,
        1140,5,152,0,0,1139,1137,1,0,0,0,1139,1140,1,0,0,0,1140,135,1,0,
        0,0,1141,1142,5,257,0,0,1142,1143,3,96,48,0,1143,1144,5,231,0,0,
        1144,1145,3,96,48,0,1145,137,1,0,0,0,1146,1147,5,259,0,0,1147,1152,
        3,140,70,0,1148,1149,5,2,0,0,1149,1151,3,140,70,0,1150,1148,1,0,
        0,0,1151,1154,1,0,0,0,1152,1150,1,0,0,0,1152,1153,1,0,0,0,1153,139,
        1,0,0,0,1154,1152,1,0,0,0,1155,1156,3,154,77,0,1156,1157,5,20,0,
        0,1157,1158,3,142,71,0,1158,141,1,0,0,0,1159,1194,3,154,77,0,1160,
        1161,5,3,0,0,1161,1162,3,154,77,0,1162,1163,5,4,0,0,1163,1194,1,
        0,0,0,1164,1175,5,3,0,0,1165,1166,7,22,0,0,1166,1167,5,28,0,0,1167,
        1172,3,96,48,0,1168,1169,5,2,0,0,1169,1171,3,96,48,0,1170,1168,1,
        0,0,0,1171,1174,1,0,0,0,1172,1170,1,0,0,0,1172,1173,1,0,0,0,1173,
        1176,1,0,0,0,1174,1172,1,0,0,0,1175,1165,1,0,0,0,1175,1176,1,0,0,
        0,1176,1187,1,0,0,0,1177,1178,7,23,0,0,1178,1179,5,28,0,0,1179,1184,
        3,34,17,0,1180,1181,5,2,0,0,1181,1183,3,34,17,0,1182,1180,1,0,0,
        0,1183,1186,1,0,0,0,1184,1182,1,0,0,0,1184,1185,1,0,0,0,1185,1188,
        1,0,0,0,1186,1184,1,0,0,0,1187,1177,1,0,0,0,1187,1188,1,0,0,0,1188,
        1190,1,0,0,0,1189,1191,3,144,72,0,1190,1189,1,0,0,0,1190,1191,1,
        0,0,0,1191,1192,1,0,0,0,1192,1194,5,4,0,0,1193,1159,1,0,0,0,1193,
        1160,1,0,0,0,1193,1164,1,0,0,0,1194,143,1,0,0,0,1195,1196,5,181,
        0,0,1196,1212,3,146,73,0,1197,1198,5,201,0,0,1198,1212,3,146,73,
        0,1199,1200,5,181,0,0,1200,1201,5,24,0,0,1201,1202,3,146,73,0,1202,
        1203,5,15,0,0,1203,1204,3,146,73,0,1204,1212,1,0,0,0,1205,1206,5,
        201,0,0,1206,1207,5,24,0,0,1207,1208,3,146,73,0,1208,1209,5,15,0,
        0,1209,1210,3,146,73,0,1210,1212,1,0,0,0,1211,1195,1,0,0,0,1211,
        1197,1,0,0,0,1211,1199,1,0,0,0,1211,1205,1,0,0,0,1212,145,1,0,0,
        0,1213,1214,5,243,0,0,1214,1221,7,24,0,0,1215,1216,5,54,0,0,1216,
        1221,5,200,0,0,1217,1218,3,96,48,0,1218,1219,7,24,0,0,1219,1221,
        1,0,0,0,1220,1213,1,0,0,0,1220,1215,1,0,0,0,1220,1217,1,0,0,0,1221,
        147,1,0,0,0,1222,1227,3,152,76,0,1223,1224,5,2,0,0,1224,1226,3,152,
        76,0,1225,1223,1,0,0,0,1226,1229,1,0,0,0,1227,1225,1,0,0,0,1227,
        1228,1,0,0,0,1228,149,1,0,0,0,1229,1227,1,0,0,0,1230,1235,3,152,
        76,0,1231,1235,5,90,0,0,1232,1235,5,129,0,0,1233,1235,5,194,0,0,
        1234,1230,1,0,0,0,1234,1231,1,0,0,0,1234,1232,1,0,0,0,1234,1233,
        1,0,0,0,1235,151,1,0,0,0,1236,1241,3,158,79,0,1237,1238,5,5,0,0,
        1238,1240,3,158,79,0,1239,1237,1,0,0,0,1240,1243,1,0,0,0,1241,1239,
        1,0,0,0,1241,1242,1,0,0,0,1242,153,1,0,0,0,1243,1241,1,0,0,0,1244,
        1245,3,158,79,0,1245,1246,3,156,78,0,1246,155,1,0,0,0,1247,1248,
        5,271,0,0,1248,1250,3,158,79,0,1249,1247,1,0,0,0,1250,1251,1,0,0,
        0,1251,1249,1,0,0,0,1251,1252,1,0,0,0,1252,1255,1,0,0,0,1253,1255,
        1,0,0,0,1254,1249,1,0,0,0,1254,1253,1,0,0,0,1255,157,1,0,0,0,1256,
        1260,3,160,80,0,1257,1258,4,79,16,0,1258,1260,3,168,84,0,1259,1256,
        1,0,0,0,1259,1257,1,0,0,0,1260,159,1,0,0,0,1261,1268,5,290,0,0,1262,
        1268,3,162,81,0,1263,1264,4,80,17,0,1264,1268,3,166,83,0,1265,1266,
        4,80,18,0,1266,1268,3,170,85,0,1267,1261,1,0,0,0,1267,1262,1,0,0,
        0,1267,1263,1,0,0,0,1267,1265,1,0,0,0,1268,161,1,0,0,0,1269,1270,
        5,291,0,0,1270,163,1,0,0,0,1271,1273,4,82,19,0,1272,1274,5,271,0,
        0,1273,1272,1,0,0,0,1273,1274,1,0,0,0,1274,1275,1,0,0,0,1275,1311,
        5,286,0,0,1276,1278,4,82,20,0,1277,1279,5,271,0,0,1278,1277,1,0,
        0,0,1278,1279,1,0,0,0,1279,1280,1,0,0,0,1280,1311,5,287,0,0,1281,
        1283,4,82,21,0,1282,1284,5,271,0,0,1283,1282,1,0,0,0,1283,1284,1,
        0,0,0,1284,1285,1,0,0,0,1285,1311,7,25,0,0,1286,1288,5,271,0,0,1287,
        1286,1,0,0,0,1287,1288,1,0,0,0,1288,1289,1,0,0,0,1289,1311,5,285,
        0,0,1290,1292,5,271,0,0,1291,1290,1,0,0,0,1291,1292,1,0,0,0,1292,
        1293,1,0,0,0,1293,1311,5,282,0,0,1294,1296,5,271,0,0,1295,1294,1,
        0,0,0,1295,1296,1,0,0,0,1296,1297,1,0,0,0,1297,1311,5,283,0,0,1298,
        1300,5,271,0,0,1299,1298,1,0,0,0,1299,1300,1,0,0,0,1300,1301,1,0,
        0,0,1301,1311,5,284,0,0,1302,1304,5,271,0,0,1303,1302,1,0,0,0,1303,
        1304,1,0,0,0,1304,1305,1,0,0,0,1305,1311,5,288,0,0,1306,1308,5,271,
        0,0,1307,1306,1,0,0,0,1307,1308,1,0,0,0,1308,1309,1,0,0,0,1309,1311,
        5,289,0,0,1310,1271,1,0,0,0,1310,1276,1,0,0,0,1310,1281,1,0,0,0,
        1310,1287,1,0,0,0,1310,1291,1,0,0,0,1310,1295,1,0,0,0,1310,1299,
        1,0,0,0,1310,1303,1,0,0,0,1310,1307,1,0,0,0,1311,165,1,0,0,0,1312,
        1313,7,26,0,0,1313,167,1,0,0,0,1314,1315,7,27,0,0,1315,169,1,0,0,
        0,1316,1317,7,28,0,0,1317,171,1,0,0,0,167,176,198,200,203,216,221,
        224,236,247,262,265,274,277,280,285,287,296,303,310,313,315,326,
        330,334,340,346,350,353,356,359,365,370,374,377,380,383,387,396,
        415,421,431,446,451,463,468,476,479,483,488,497,500,505,512,515,
        523,530,537,540,545,548,553,557,560,563,569,580,589,596,612,621,
        624,630,634,636,643,651,657,664,670,674,676,683,698,700,708,710,
        714,722,731,737,745,750,762,767,770,776,780,785,790,795,801,822,
        824,833,837,846,850,868,871,879,888,911,922,929,932,941,945,957,
        982,989,992,1007,1011,1021,1023,1036,1038,1051,1055,1062,1067,1075,
        1079,1088,1105,1109,1118,1122,1124,1131,1139,1152,1172,1175,1184,
        1187,1190,1193,1211,1220,1227,1234,1241,1251,1254,1259,1267,1273,
        1278,1283,1287,1291,1295,1299,1303,1307,1310
    ]

class SqlBaseParser ( Parser ):

    grammarFileName = "SqlBase.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "','", "'('", "')'", "'.'", "'->'", 
                     "'['", "']'", "':'", "'ADD'", "'AFTER'", "'ALL'", "'ALTER'", 
                     "'ANALYZE'", "'AND'", "'ANTI'", "'ANY'", "'ARCHIVE'", 
                     "'ARRAY'", "'AS'", "'ASC'", "'AT'", "'AUTHORIZATION'", 
                     "'BETWEEN'", "'BOTH'", "'BUCKET'", "'BUCKETS'", "'BY'", 
                     "'CACHE'", "'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", 
                     "'CHECK'", "'CLEAR'", "'CLUSTER'", "'CLUSTERED'", "'CODEGEN'", 
                     "'COLLATE'", "'COLLECTION'", "'COLUMN'", "'COLUMNS'", 
                     "'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPACTIONS'", 
                     "'COMPUTE'", "'CONCATENATE'", "'CONSTRAINT'", "'COST'", 
                     "'CREATE'", "'CROSS'", "'CUBE'", "'CURRENT'", "'CURRENT_DATE'", 
                     "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", 
                     "'DATA'", "'DATABASE'", "<INVALID>", "'DAY'", "'DBPROPERTIES'", 
                     "'DEFINED'", "'DELETE'", "'DELIMITED'", "'DESC'", "'DESCRIBE'", 
                     "'DFS'", "'DIRECTORIES'", "'DIRECTORY'", "'DISTINCT'", 
                     "'DISTRIBUTE'", "'DROP'", "'ELSE'", "'END'", "'ESCAPE'", 
                     "'ESCAPED'", "'EXCEPT'", "'EXCHANGE'", "'EXISTS'", 
                     "'EXPLAIN'", "'EXPORT'", "'EXTENDED'", "'EXTERNAL'", 
                     "'EXTRACT'", "'FALSE'", "'FETCH'", "'FIELDS'", "'FILTER'", 
                     "'FILEFORMAT'", "'FIRST'", "'FOLLOWING'", "'FOR'", 
                     "'FOREIGN'", "'FORMAT'", "'FORMATTED'", "'FROM'", "'FULL'", 
                     "'FUNCTION'", "'FUNCTIONS'", "'GLOBAL'", "'GRANT'", 
                     "'GROUP'", "'GROUPING'", "'HAVING'", "'HOUR'", "'IF'", 
                     "'IGNORE'", "'IMPORT'", "'IN'", "'INDEX'", "'INDEXES'", 
                     "'INNER'", "'INPATH'", "'INPUTFORMAT'", "'INSERT'", 
                     "'INTERSECT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITEMS'", 
                     "'JOIN'", "'KEYS'", "'LAST'", "'LATERAL'", "'LAZY'", 
                     "'LEADING'", "'LEFT'", "'LIKE'", "'LIMIT'", "'LINES'", 
                     "'LIST'", "'LOAD'", "'LOCAL'", "'LOCATION'", "'LOCK'", 
                     "'LOCKS'", "'LOGICAL'", "'MACRO'", "'MAP'", "'MATCHED'", 
                     "'MERGE'", "'MINUTE'", "'MONTH'", "'MSCK'", "'NAMESPACE'", 
                     "'NAMESPACES'", "'NATURAL'", "'NO'", "<INVALID>", "'NULL'", 
                     "'NULLS'", "'OF'", "'ON'", "'ONLY'", "'OPTION'", "'OPTIONS'", 
                     "'OR'", "'ORDER'", "'OUT'", "'OUTER'", "'OUTPUTFORMAT'", 
                     "'OVER'", "'OVERLAPS'", "'OVERLAY'", "'OVERWRITE'", 
                     "'PARTITION'", "'PARTITIONED'", "'PARTITIONS'", "'PERCENT'", 
                     "'PIVOT'", "'PLACING'", "'POSITION'", "'PRECEDING'", 
                     "'PRIMARY'", "'PRINCIPALS'", "'PROPERTIES'", "'PURGE'", 
                     "'QUERY'", "'RANGE'", "'RECORDREADER'", "'RECORDWRITER'", 
                     "'RECOVER'", "'REDUCE'", "'REFERENCES'", "'REFRESH'", 
                     "'RENAME'", "'REPAIR'", "'REPLACE'", "'RESET'", "'RESTRICT'", 
                     "'REVOKE'", "'RIGHT'", "<INVALID>", "'ROLE'", "'ROLES'", 
                     "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'", "'SCHEMA'", 
                     "'SECOND'", "'SELECT'", "'SEMI'", "'SEPARATED'", "'SERDE'", 
                     "'SERDEPROPERTIES'", "'SESSION_USER'", "'SET'", "'MINUS'", 
                     "'SETS'", "'SHOW'", "'SKEWED'", "'SOME'", "'SORT'", 
                     "'SORTED'", "'START'", "'STATISTICS'", "'STORED'", 
                     "'STRATIFY'", "'STRUCT'", "'SUBSTR'", "'SUBSTRING'", 
                     "'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TBLPROPERTIES'", 
                     "<INVALID>", "'TERMINATED'", "'THEN'", "'TO'", "'TOUCH'", 
                     "'TRAILING'", "'TRANSACTION'", "'TRANSACTIONS'", "'TRANSFORM'", 
                     "'TRIM'", "'TRUE'", "'TRUNCATE'", "'TYPE'", "'UNARCHIVE'", 
                     "'UNBOUNDED'", "'UNCACHE'", "'UNION'", "'UNIQUE'", 
                     "'UNKNOWN'", "'UNLOCK'", "'UNSET'", "'UPDATE'", "'USE'", 
                     "'USER'", "'USING'", "'VALUES'", "'VIEW'", "'VIEWS'", 
                     "'WHEN'", "'WHERE'", "'WINDOW'", "'WITH'", "'YEAR'", 
                     "<INVALID>", "'<=>'", "'<>'", "'!='", "'<'", "<INVALID>", 
                     "'>'", "<INVALID>", "'+'", "'-'", "'*'", "'/'", "'%'", 
                     "'DIV'", "'~'", "'&'", "'|'", "'||'", "'^'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "ADD", "AFTER", "ALL", "ALTER", 
                      "ANALYZE", "AND", "ANTI", "ANY", "ARCHIVE", "ARRAY", 
                      "AS", "ASC", "AT", "AUTHORIZATION", "BETWEEN", "BOTH", 
                      "BUCKET", "BUCKETS", "BY", "CACHE", "CASCADE", "CASE", 
                      "CAST", "CHANGE", "CHECK", "CLEAR", "CLUSTER", "CLUSTERED", 
                      "CODEGEN", "COLLATE", "COLLECTION", "COLUMN", "COLUMNS", 
                      "COMMENT", "COMMIT", "COMPACT", "COMPACTIONS", "COMPUTE", 
                      "CONCATENATE", "CONSTRAINT", "COST", "CREATE", "CROSS", 
                      "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", 
                      "CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", 
                      "DATABASES", "DAY", "DBPROPERTIES", "DEFINED", "DELETE", 
                      "DELIMITED", "DESC", "DESCRIBE", "DFS", "DIRECTORIES", 
                      "DIRECTORY", "DISTINCT", "DISTRIBUTE", "DROP", "ELSE", 
                      "END", "ESCAPE", "ESCAPED", "EXCEPT", "EXCHANGE", 
                      "EXISTS", "EXPLAIN", "EXPORT", "EXTENDED", "EXTERNAL", 
                      "EXTRACT", "FALSE", "FETCH", "FIELDS", "FILTER", "FILEFORMAT", 
                      "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FORMAT", 
                      "FORMATTED", "FROM", "FULL", "FUNCTION", "FUNCTIONS", 
                      "GLOBAL", "GRANT", "GROUP", "GROUPING", "HAVING", 
                      "HOUR", "IF", "IGNORE", "IMPORT", "IN", "INDEX", "INDEXES", 
                      "INNER", "INPATH", "INPUTFORMAT", "INSERT", "INTERSECT", 
                      "INTERVAL", "INTO", "IS", "ITEMS", "JOIN", "KEYS", 
                      "LAST", "LATERAL", "LAZY", "LEADING", "LEFT", "LIKE", 
                      "LIMIT", "LINES", "LIST", "LOAD", "LOCAL", "LOCATION", 
                      "LOCK", "LOCKS", "LOGICAL", "MACRO", "MAP", "MATCHED", 
                      "MERGE", "MINUTE", "MONTH", "MSCK", "NAMESPACE", "NAMESPACES", 
                      "NATURAL", "NO", "NOT", "NULL", "NULLS", "OF", "ON", 
                      "ONLY", "OPTION", "OPTIONS", "OR", "ORDER", "OUT", 
                      "OUTER", "OUTPUTFORMAT", "OVER", "OVERLAPS", "OVERLAY", 
                      "OVERWRITE", "PARTITION", "PARTITIONED", "PARTITIONS", 
                      "PERCENTLIT", "PIVOT", "PLACING", "POSITION", "PRECEDING", 
                      "PRIMARY", "PRINCIPALS", "PROPERTIES", "PURGE", "QUERY", 
                      "RANGE", "RECORDREADER", "RECORDWRITER", "RECOVER", 
                      "REDUCE", "REFERENCES", "REFRESH", "RENAME", "REPAIR", 
                      "REPLACE", "RESET", "RESTRICT", "REVOKE", "RIGHT", 
                      "RLIKE", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", 
                      "ROWS", "SCHEMA", "SECOND", "SELECT", "SEMI", "SEPARATED", 
                      "SERDE", "SERDEPROPERTIES", "SESSION_USER", "SET", 
                      "SETMINUS", "SETS", "SHOW", "SKEWED", "SOME", "SORT", 
                      "SORTED", "START", "STATISTICS", "STORED", "STRATIFY", 
                      "STRUCT", "SUBSTR", "SUBSTRING", "TABLE", "TABLES", 
                      "TABLESAMPLE", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", 
                      "THEN", "TO", "TOUCH", "TRAILING", "TRANSACTION", 
                      "TRANSACTIONS", "TRANSFORM", "TRIM", "TRUE", "TRUNCATE", 
                      "TYPE", "UNARCHIVE", "UNBOUNDED", "UNCACHE", "UNION", 
                      "UNIQUE", "UNKNOWN", "UNLOCK", "UNSET", "UPDATE", 
                      "USE", "USER", "USING", "VALUES", "VIEW", "VIEWS", 
                      "WHEN", "WHERE", "WINDOW", "WITH", "YEAR", "EQ", "NSEQ", 
                      "NEQ", "NEQJ", "LT", "LTE", "GT", "GTE", "PLUS", "MINUS", 
                      "ASTERISK", "SLASH", "PERCENT", "DIV", "TILDE", "AMPERSAND", 
                      "PIPE", "CONCAT_PIPE", "HAT", "STRING", "BIGINT_LITERAL", 
                      "SMALLINT_LITERAL", "TINYINT_LITERAL", "INTEGER_VALUE", 
                      "EXPONENT_VALUE", "DECIMAL_VALUE", "DOUBLE_LITERAL", 
                      "BIGDECIMAL_LITERAL", "IDENTIFIER", "BACKQUOTED_IDENTIFIER", 
                      "SIMPLE_COMMENT", "BRACKETED_COMMENT", "WS", "UNRECOGNIZED" ]

    RULE_singleStatement = 0
    RULE_singleExpression = 1
    RULE_singleTableIdentifier = 2
    RULE_singleMultipartIdentifier = 3
    RULE_singleFunctionIdentifier = 4
    RULE_singleDataType = 5
    RULE_statement = 6
    RULE_query = 7
    RULE_namespace = 8
    RULE_ctes = 9
    RULE_namedQuery = 10
    RULE_constantList = 11
    RULE_nestedConstantList = 12
    RULE_resource = 13
    RULE_queryOrganization = 14
    RULE_queryTerm = 15
    RULE_queryPrimary = 16
    RULE_sortItem = 17
    RULE_fromStatement = 18
    RULE_fromStatementBody = 19
    RULE_querySpecification = 20
    RULE_selectClause = 21
    RULE_assignmentList = 22
    RULE_assignment = 23
    RULE_whereClause = 24
    RULE_havingClause = 25
    RULE_fromClause = 26
    RULE_aggregationClause = 27
    RULE_groupingSet = 28
    RULE_lateralView = 29
    RULE_setQuantifier = 30
    RULE_relation = 31
    RULE_joinRelation = 32
    RULE_joinType = 33
    RULE_joinCriteria = 34
    RULE_identifierList = 35
    RULE_identifierSeq = 36
    RULE_orderedIdentifierList = 37
    RULE_orderedIdentifier = 38
    RULE_relationPrimary = 39
    RULE_functionTable = 40
    RULE_tableAlias = 41
    RULE_multipartIdentifierList = 42
    RULE_multipartIdentifier = 43
    RULE_tableIdentifier = 44
    RULE_functionIdentifier = 45
    RULE_namedExpression = 46
    RULE_namedExpressionSeq = 47
    RULE_expression = 48
    RULE_booleanExpression = 49
    RULE_predicate = 50
    RULE_valueExpression = 51
    RULE_primaryExpression = 52
    RULE_constant = 53
    RULE_comparisonOperator = 54
    RULE_arithmeticOperator = 55
    RULE_predicateOperator = 56
    RULE_booleanValue = 57
    RULE_interval = 58
    RULE_errorCapturingMultiUnitsInterval = 59
    RULE_multiUnitsInterval = 60
    RULE_errorCapturingUnitToUnitInterval = 61
    RULE_unitToUnitInterval = 62
    RULE_intervalValue = 63
    RULE_intervalUnit = 64
    RULE_dataType = 65
    RULE_complexColTypeList = 66
    RULE_complexColType = 67
    RULE_whenClause = 68
    RULE_windowClause = 69
    RULE_namedWindow = 70
    RULE_windowSpec = 71
    RULE_windowFrame = 72
    RULE_frameBound = 73
    RULE_qualifiedNameList = 74
    RULE_functionName = 75
    RULE_qualifiedName = 76
    RULE_errorCapturingIdentifier = 77
    RULE_errorCapturingIdentifierExtra = 78
    RULE_identifier = 79
    RULE_strictIdentifier = 80
    RULE_quotedIdentifier = 81
    RULE_number = 82
    RULE_ansiNonReserved = 83
    RULE_strictNonReserved = 84
    RULE_nonReserved = 85

    ruleNames =  [ "singleStatement", "singleExpression", "singleTableIdentifier", 
                   "singleMultipartIdentifier", "singleFunctionIdentifier", 
                   "singleDataType", "statement", "query", "namespace", 
                   "ctes", "namedQuery", "constantList", "nestedConstantList", 
                   "resource", "queryOrganization", "queryTerm", "queryPrimary", 
                   "sortItem", "fromStatement", "fromStatementBody", "querySpecification", 
                   "selectClause", "assignmentList", "assignment", "whereClause", 
                   "havingClause", "fromClause", "aggregationClause", "groupingSet", 
                   "lateralView", "setQuantifier", "relation", "joinRelation", 
                   "joinType", "joinCriteria", "identifierList", "identifierSeq", 
                   "orderedIdentifierList", "orderedIdentifier", "relationPrimary", 
                   "functionTable", "tableAlias", "multipartIdentifierList", 
                   "multipartIdentifier", "tableIdentifier", "functionIdentifier", 
                   "namedExpression", "namedExpressionSeq", "expression", 
                   "booleanExpression", "predicate", "valueExpression", 
                   "primaryExpression", "constant", "comparisonOperator", 
                   "arithmeticOperator", "predicateOperator", "booleanValue", 
                   "interval", "errorCapturingMultiUnitsInterval", "multiUnitsInterval", 
                   "errorCapturingUnitToUnitInterval", "unitToUnitInterval", 
                   "intervalValue", "intervalUnit", "dataType", "complexColTypeList", 
                   "complexColType", "whenClause", "windowClause", "namedWindow", 
                   "windowSpec", "windowFrame", "frameBound", "qualifiedNameList", 
                   "functionName", "qualifiedName", "errorCapturingIdentifier", 
                   "errorCapturingIdentifierExtra", "identifier", "strictIdentifier", 
                   "quotedIdentifier", "number", "ansiNonReserved", "strictNonReserved", 
                   "nonReserved" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    ADD=10
    AFTER=11
    ALL=12
    ALTER=13
    ANALYZE=14
    AND=15
    ANTI=16
    ANY=17
    ARCHIVE=18
    ARRAY=19
    AS=20
    ASC=21
    AT=22
    AUTHORIZATION=23
    BETWEEN=24
    BOTH=25
    BUCKET=26
    BUCKETS=27
    BY=28
    CACHE=29
    CASCADE=30
    CASE=31
    CAST=32
    CHANGE=33
    CHECK=34
    CLEAR=35
    CLUSTER=36
    CLUSTERED=37
    CODEGEN=38
    COLLATE=39
    COLLECTION=40
    COLUMN=41
    COLUMNS=42
    COMMENT=43
    COMMIT=44
    COMPACT=45
    COMPACTIONS=46
    COMPUTE=47
    CONCATENATE=48
    CONSTRAINT=49
    COST=50
    CREATE=51
    CROSS=52
    CUBE=53
    CURRENT=54
    CURRENT_DATE=55
    CURRENT_TIME=56
    CURRENT_TIMESTAMP=57
    CURRENT_USER=58
    DATA=59
    DATABASE=60
    DATABASES=61
    DAY=62
    DBPROPERTIES=63
    DEFINED=64
    DELETE=65
    DELIMITED=66
    DESC=67
    DESCRIBE=68
    DFS=69
    DIRECTORIES=70
    DIRECTORY=71
    DISTINCT=72
    DISTRIBUTE=73
    DROP=74
    ELSE=75
    END=76
    ESCAPE=77
    ESCAPED=78
    EXCEPT=79
    EXCHANGE=80
    EXISTS=81
    EXPLAIN=82
    EXPORT=83
    EXTENDED=84
    EXTERNAL=85
    EXTRACT=86
    FALSE=87
    FETCH=88
    FIELDS=89
    FILTER=90
    FILEFORMAT=91
    FIRST=92
    FOLLOWING=93
    FOR=94
    FOREIGN=95
    FORMAT=96
    FORMATTED=97
    FROM=98
    FULL=99
    FUNCTION=100
    FUNCTIONS=101
    GLOBAL=102
    GRANT=103
    GROUP=104
    GROUPING=105
    HAVING=106
    HOUR=107
    IF=108
    IGNORE=109
    IMPORT=110
    IN=111
    INDEX=112
    INDEXES=113
    INNER=114
    INPATH=115
    INPUTFORMAT=116
    INSERT=117
    INTERSECT=118
    INTERVAL=119
    INTO=120
    IS=121
    ITEMS=122
    JOIN=123
    KEYS=124
    LAST=125
    LATERAL=126
    LAZY=127
    LEADING=128
    LEFT=129
    LIKE=130
    LIMIT=131
    LINES=132
    LIST=133
    LOAD=134
    LOCAL=135
    LOCATION=136
    LOCK=137
    LOCKS=138
    LOGICAL=139
    MACRO=140
    MAP=141
    MATCHED=142
    MERGE=143
    MINUTE=144
    MONTH=145
    MSCK=146
    NAMESPACE=147
    NAMESPACES=148
    NATURAL=149
    NO=150
    NOT=151
    NULL=152
    NULLS=153
    OF=154
    ON=155
    ONLY=156
    OPTION=157
    OPTIONS=158
    OR=159
    ORDER=160
    OUT=161
    OUTER=162
    OUTPUTFORMAT=163
    OVER=164
    OVERLAPS=165
    OVERLAY=166
    OVERWRITE=167
    PARTITION=168
    PARTITIONED=169
    PARTITIONS=170
    PERCENTLIT=171
    PIVOT=172
    PLACING=173
    POSITION=174
    PRECEDING=175
    PRIMARY=176
    PRINCIPALS=177
    PROPERTIES=178
    PURGE=179
    QUERY=180
    RANGE=181
    RECORDREADER=182
    RECORDWRITER=183
    RECOVER=184
    REDUCE=185
    REFERENCES=186
    REFRESH=187
    RENAME=188
    REPAIR=189
    REPLACE=190
    RESET=191
    RESTRICT=192
    REVOKE=193
    RIGHT=194
    RLIKE=195
    ROLE=196
    ROLES=197
    ROLLBACK=198
    ROLLUP=199
    ROW=200
    ROWS=201
    SCHEMA=202
    SECOND=203
    SELECT=204
    SEMI=205
    SEPARATED=206
    SERDE=207
    SERDEPROPERTIES=208
    SESSION_USER=209
    SET=210
    SETMINUS=211
    SETS=212
    SHOW=213
    SKEWED=214
    SOME=215
    SORT=216
    SORTED=217
    START=218
    STATISTICS=219
    STORED=220
    STRATIFY=221
    STRUCT=222
    SUBSTR=223
    SUBSTRING=224
    TABLE=225
    TABLES=226
    TABLESAMPLE=227
    TBLPROPERTIES=228
    TEMPORARY=229
    TERMINATED=230
    THEN=231
    TO=232
    TOUCH=233
    TRAILING=234
    TRANSACTION=235
    TRANSACTIONS=236
    TRANSFORM=237
    TRIM=238
    TRUE=239
    TRUNCATE=240
    TYPE=241
    UNARCHIVE=242
    UNBOUNDED=243
    UNCACHE=244
    UNION=245
    UNIQUE=246
    UNKNOWN=247
    UNLOCK=248
    UNSET=249
    UPDATE=250
    USE=251
    USER=252
    USING=253
    VALUES=254
    VIEW=255
    VIEWS=256
    WHEN=257
    WHERE=258
    WINDOW=259
    WITH=260
    YEAR=261
    EQ=262
    NSEQ=263
    NEQ=264
    NEQJ=265
    LT=266
    LTE=267
    GT=268
    GTE=269
    PLUS=270
    MINUS=271
    ASTERISK=272
    SLASH=273
    PERCENT=274
    DIV=275
    TILDE=276
    AMPERSAND=277
    PIPE=278
    CONCAT_PIPE=279
    HAT=280
    STRING=281
    BIGINT_LITERAL=282
    SMALLINT_LITERAL=283
    TINYINT_LITERAL=284
    INTEGER_VALUE=285
    EXPONENT_VALUE=286
    DECIMAL_VALUE=287
    DOUBLE_LITERAL=288
    BIGDECIMAL_LITERAL=289
    IDENTIFIER=290
    BACKQUOTED_IDENTIFIER=291
    SIMPLE_COMMENT=292
    BRACKETED_COMMENT=293
    WS=294
    UNRECOGNIZED=295

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    """
    When false, INTERSECT is given the greater precedence over the other set
    operations (UNION, EXCEPT and MINUS) as per the SQL standard.
    """
    legacy_setops_precedence_enbled = True

    """
    When false, a literal with an exponent would be converted into
    double type rather than decimal type.
    """
    legacy_exponent_literal_as_decimal_enabled = True

    """
    When true, the behavior of keywords follows ANSI SQL standard.
    """
    SQL_standard_keyword_behavior = True

    def isValidDecimal(self):
        """
        Verify whether current token is a valid decimal token (which contains dot).
        Returns true if the character that follows the token is not a digit or letter or underscore.

        For example:
        For char stream "2.3", "2." is not a valid decimal token, because it is followed by digit '3'.
        For char stream "2.3_", "2.3" is not a valid decimal token, because it is followed by '_'.
        For char stream "2.3W", "2.3" is not a valid decimal token, because it is followed by 'W'.
        For char stream "12.0D 34.E2+0.12 "  12.0D is a valid decimal token because it is followed
        by a space. 34.E2 is a valid decimal token because it is followed by symbol '+'
        which is not a digit or letter or underscore.
        """
        nextChar = self._input.LA(1)
        if 'A' <= nextChar <= 'Z' or '0' <= nextChar <= '9' or nextChar == '_':
            return False
        else:
            return True



    class SingleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(SqlBaseParser.StatementContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleStatement" ):
                listener.enterSingleStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleStatement" ):
                listener.exitSingleStatement(self)




    def singleStatement(self):

        localctx = SqlBaseParser.SingleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_singleStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.statement()
            self.state = 176
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 173
                self.match(SqlBaseParser.T__0)
                self.state = 178
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 179
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.NamedExpressionContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleExpression" ):
                listener.enterSingleExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleExpression" ):
                listener.exitSingleExpression(self)




    def singleExpression(self):

        localctx = SqlBaseParser.SingleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_singleExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.namedExpression()
            self.state = 182
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleTableIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.TableIdentifierContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleTableIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleTableIdentifier" ):
                listener.enterSingleTableIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleTableIdentifier" ):
                listener.exitSingleTableIdentifier(self)




    def singleTableIdentifier(self):

        localctx = SqlBaseParser.SingleTableIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_singleTableIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.tableIdentifier()
            self.state = 185
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleMultipartIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multipartIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.MultipartIdentifierContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleMultipartIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleMultipartIdentifier" ):
                listener.enterSingleMultipartIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleMultipartIdentifier" ):
                listener.exitSingleMultipartIdentifier(self)




    def singleMultipartIdentifier(self):

        localctx = SqlBaseParser.SingleMultipartIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_singleMultipartIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.multipartIdentifier()
            self.state = 188
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleFunctionIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.FunctionIdentifierContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleFunctionIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleFunctionIdentifier" ):
                listener.enterSingleFunctionIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleFunctionIdentifier" ):
                listener.exitSingleFunctionIdentifier(self)




    def singleFunctionIdentifier(self):

        localctx = SqlBaseParser.SingleFunctionIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_singleFunctionIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.functionIdentifier()
            self.state = 191
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleDataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataType(self):
            return self.getTypedRuleContext(SqlBaseParser.DataTypeContext,0)


        def EOF(self):
            return self.getToken(SqlBaseParser.EOF, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_singleDataType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleDataType" ):
                listener.enterSingleDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleDataType" ):
                listener.exitSingleDataType(self)




    def singleDataType(self):

        localctx = SqlBaseParser.SingleDataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_singleDataType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.dataType()
            self.state = 194
            self.match(SqlBaseParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class StatementDefaultContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementDefault" ):
                listener.enterStatementDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementDefault" ):
                listener.exitStatementDefault(self)


    class DmlStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ctes(self):
            return self.getTypedRuleContext(SqlBaseParser.CtesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDmlStatement" ):
                listener.enterDmlStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDmlStatement" ):
                listener.exitDmlStatement(self)



    def statement(self):

        localctx = SqlBaseParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 200
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.StatementDefaultContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 196
                self.query()
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.DmlStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 198
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==260:
                    self.state = 197
                    self.ctes()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryTerm(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryTermContext,0)


        def queryOrganization(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryOrganizationContext,0)


        def ctes(self):
            return self.getTypedRuleContext(SqlBaseParser.CtesContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)




    def query(self):

        localctx = SqlBaseParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==260:
                self.state = 202
                self.ctes()


            self.state = 205
            self.queryTerm(0)
            self.state = 206
            self.queryOrganization()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAMESPACE(self):
            return self.getToken(SqlBaseParser.NAMESPACE, 0)

        def DATABASE(self):
            return self.getToken(SqlBaseParser.DATABASE, 0)

        def SCHEMA(self):
            return self.getToken(SqlBaseParser.SCHEMA, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_namespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamespace" ):
                listener.enterNamespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamespace" ):
                listener.exitNamespace(self)




    def namespace(self):

        localctx = SqlBaseParser.NamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_namespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            _la = self._input.LA(1)
            if not(_la==60 or _la==147 or _la==202):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CtesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(SqlBaseParser.WITH, 0)

        def namedQuery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.NamedQueryContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.NamedQueryContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_ctes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCtes" ):
                listener.enterCtes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCtes" ):
                listener.exitCtes(self)




    def ctes(self):

        localctx = SqlBaseParser.CtesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_ctes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 210
            self.match(SqlBaseParser.WITH)
            self.state = 211
            self.namedQuery()
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 212
                self.match(SqlBaseParser.T__1)
                self.state = 213
                self.namedQuery()
                self.state = 218
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # ErrorCapturingIdentifierContext
            self.columnAliases = None # IdentifierListContext

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,0)


        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def identifierList(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_namedQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedQuery" ):
                listener.enterNamedQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedQuery" ):
                listener.exitNamedQuery(self)




    def namedQuery(self):

        localctx = SqlBaseParser.NamedQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_namedQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            localctx.name = self.errorCapturingIdentifier()
            self.state = 221
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 220
                localctx.columnAliases = self.identifierList()


            self.state = 224
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 223
                self.match(SqlBaseParser.AS)


            self.state = 226
            self.match(SqlBaseParser.T__2)
            self.state = 227
            self.query()
            self.state = 228
            self.match(SqlBaseParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ConstantContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ConstantContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_constantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantList" ):
                listener.enterConstantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantList" ):
                listener.exitConstantList(self)




    def constantList(self):

        localctx = SqlBaseParser.ConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_constantList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(SqlBaseParser.T__2)
            self.state = 231
            self.constant()
            self.state = 236
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 232
                self.match(SqlBaseParser.T__1)
                self.state = 233
                self.constant()
                self.state = 238
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 239
            self.match(SqlBaseParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedConstantListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ConstantListContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ConstantListContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_nestedConstantList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNestedConstantList" ):
                listener.enterNestedConstantList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNestedConstantList" ):
                listener.exitNestedConstantList(self)




    def nestedConstantList(self):

        localctx = SqlBaseParser.NestedConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_nestedConstantList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(SqlBaseParser.T__2)
            self.state = 242
            self.constantList()
            self.state = 247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 243
                self.match(SqlBaseParser.T__1)
                self.state = 244
                self.constantList()
                self.state = 249
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 250
            self.match(SqlBaseParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_resource

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResource" ):
                listener.enterResource(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResource" ):
                listener.exitResource(self)




    def resource(self):

        localctx = SqlBaseParser.ResourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_resource)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self.identifier()
            self.state = 253
            self.match(SqlBaseParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryOrganizationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._sortItem = None # SortItemContext
            self.order = list() # of SortItemContexts
            self.sort = list() # of SortItemContexts
            self.limit = None # ExpressionContext

        def ORDER(self):
            return self.getToken(SqlBaseParser.ORDER, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.BY)
            else:
                return self.getToken(SqlBaseParser.BY, i)

        def SORT(self):
            return self.getToken(SqlBaseParser.SORT, 0)

        def windowClause(self):
            return self.getTypedRuleContext(SqlBaseParser.WindowClauseContext,0)


        def LIMIT(self):
            return self.getToken(SqlBaseParser.LIMIT, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.SortItemContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.SortItemContext,i)


        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_queryOrganization

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryOrganization" ):
                listener.enterQueryOrganization(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryOrganization" ):
                listener.exitQueryOrganization(self)




    def queryOrganization(self):

        localctx = SqlBaseParser.QueryOrganizationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_queryOrganization)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 265
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 255
                self.match(SqlBaseParser.ORDER)
                self.state = 256
                self.match(SqlBaseParser.BY)
                self.state = 257
                localctx._sortItem = self.sortItem()
                localctx.order.append(localctx._sortItem)
                self.state = 262
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 258
                        self.match(SqlBaseParser.T__1)
                        self.state = 259
                        localctx._sortItem = self.sortItem()
                        localctx.order.append(localctx._sortItem) 
                    self.state = 264
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,9,self._ctx)



            self.state = 277
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 267
                self.match(SqlBaseParser.SORT)
                self.state = 268
                self.match(SqlBaseParser.BY)
                self.state = 269
                localctx._sortItem = self.sortItem()
                localctx.sort.append(localctx._sortItem)
                self.state = 274
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,11,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 270
                        self.match(SqlBaseParser.T__1)
                        self.state = 271
                        localctx._sortItem = self.sortItem()
                        localctx.sort.append(localctx._sortItem) 
                    self.state = 276
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,11,self._ctx)



            self.state = 280
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.state = 279
                self.windowClause()


            self.state = 287
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 282
                self.match(SqlBaseParser.LIMIT)
                self.state = 285
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                if la_ == 1:
                    self.state = 283
                    self.match(SqlBaseParser.ALL)
                    pass

                elif la_ == 2:
                    self.state = 284
                    localctx.limit = self.expression()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_queryTerm

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class QueryTermDefaultContext(QueryTermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryTermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def queryPrimary(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryPrimaryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryTermDefault" ):
                listener.enterQueryTermDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryTermDefault" ):
                listener.exitQueryTermDefault(self)


    class SetOperationContext(QueryTermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryTermContext
            super().__init__(parser)
            self.left = None # QueryTermContext
            self.operator = None # Token
            self.right = None # QueryTermContext
            self.copyFrom(ctx)

        def queryTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.QueryTermContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.QueryTermContext,i)

        def INTERSECT(self):
            return self.getToken(SqlBaseParser.INTERSECT, 0)
        def UNION(self):
            return self.getToken(SqlBaseParser.UNION, 0)
        def EXCEPT(self):
            return self.getToken(SqlBaseParser.EXCEPT, 0)
        def SETMINUS(self):
            return self.getToken(SqlBaseParser.SETMINUS, 0)
        def setQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.SetQuantifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetOperation" ):
                listener.enterSetOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetOperation" ):
                listener.exitSetOperation(self)



    def queryTerm(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.QueryTermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 30
        self.enterRecursionRule(localctx, 30, self.RULE_queryTerm, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = SqlBaseParser.QueryTermDefaultContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 290
            self.queryPrimary()
            self._ctx.stop = self._input.LT(-1)
            self.state = 315
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 313
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                    if la_ == 1:
                        localctx = SqlBaseParser.SetOperationContext(self, SqlBaseParser.QueryTermContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_queryTerm)
                        self.state = 292
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 293
                        if not self.legacy_setops_precedence_enbled:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.legacy_setops_precedence_enbled")
                        self.state = 294
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==79 or _la==118 or _la==211 or _la==245):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 296
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==12 or _la==72:
                            self.state = 295
                            self.setQuantifier()


                        self.state = 298
                        localctx.right = self.queryTerm(4)
                        pass

                    elif la_ == 2:
                        localctx = SqlBaseParser.SetOperationContext(self, SqlBaseParser.QueryTermContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_queryTerm)
                        self.state = 299
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 300
                        if not not self.legacy_setops_precedence_enbled:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "not self.legacy_setops_precedence_enbled")
                        self.state = 301
                        localctx.operator = self.match(SqlBaseParser.INTERSECT)
                        self.state = 303
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==12 or _la==72:
                            self.state = 302
                            self.setQuantifier()


                        self.state = 305
                        localctx.right = self.queryTerm(3)
                        pass

                    elif la_ == 3:
                        localctx = SqlBaseParser.SetOperationContext(self, SqlBaseParser.QueryTermContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_queryTerm)
                        self.state = 306
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 307
                        if not not self.legacy_setops_precedence_enbled:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "not self.legacy_setops_precedence_enbled")
                        self.state = 308
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==79 or _la==211 or _la==245):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 310
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==12 or _la==72:
                            self.state = 309
                            self.setQuantifier()


                        self.state = 312
                        localctx.right = self.queryTerm(2)
                        pass

             
                self.state = 317
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class QueryPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_queryPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubqueryContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubquery" ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubquery" ):
                listener.exitSubquery(self)


    class QueryPrimaryDefaultContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def querySpecification(self):
            return self.getTypedRuleContext(SqlBaseParser.QuerySpecificationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryPrimaryDefault" ):
                listener.enterQueryPrimaryDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryPrimaryDefault" ):
                listener.exitQueryPrimaryDefault(self)


    class FromStmtContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fromStatement(self):
            return self.getTypedRuleContext(SqlBaseParser.FromStatementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromStmt" ):
                listener.enterFromStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromStmt" ):
                listener.exitFromStmt(self)


    class TableContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TABLE(self):
            return self.getToken(SqlBaseParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.MultipartIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable" ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable" ):
                listener.exitTable(self)



    def queryPrimary(self):

        localctx = SqlBaseParser.QueryPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_queryPrimary)
        try:
            self.state = 326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [204]:
                localctx = SqlBaseParser.QueryPrimaryDefaultContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 318
                self.querySpecification()
                pass
            elif token in [98]:
                localctx = SqlBaseParser.FromStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 319
                self.fromStatement()
                pass
            elif token in [225]:
                localctx = SqlBaseParser.TableContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 320
                self.match(SqlBaseParser.TABLE)
                self.state = 321
                self.multipartIdentifier()
                pass
            elif token in [3]:
                localctx = SqlBaseParser.SubqueryContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 322
                self.match(SqlBaseParser.T__2)
                self.state = 323
                self.query()
                self.state = 324
                self.match(SqlBaseParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ordering = None # Token
            self.nullOrder = None # Token

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def ASC(self):
            return self.getToken(SqlBaseParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlBaseParser.DESC, 0)

        def LAST(self):
            return self.getToken(SqlBaseParser.LAST, 0)

        def FIRST(self):
            return self.getToken(SqlBaseParser.FIRST, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_sortItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortItem" ):
                listener.enterSortItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortItem" ):
                listener.exitSortItem(self)




    def sortItem(self):

        localctx = SqlBaseParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.expression()
            self.state = 330
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.state = 329
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==21 or _la==67):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 334
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 332
                self.match(SqlBaseParser.NULLS)
                self.state = 333
                localctx.nullOrder = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==92 or _la==125):
                    localctx.nullOrder = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fromClause(self):
            return self.getTypedRuleContext(SqlBaseParser.FromClauseContext,0)


        def fromStatementBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.FromStatementBodyContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.FromStatementBodyContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_fromStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromStatement" ):
                listener.enterFromStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromStatement" ):
                listener.exitFromStatement(self)




    def fromStatement(self):

        localctx = SqlBaseParser.FromStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_fromStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.fromClause()
            self.state = 338 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 337
                    self.fromStatementBody()

                else:
                    raise NoViableAltException(self)
                self.state = 340 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,24,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromStatementBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectClause(self):
            return self.getTypedRuleContext(SqlBaseParser.SelectClauseContext,0)


        def queryOrganization(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryOrganizationContext,0)


        def lateralView(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.LateralViewContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.LateralViewContext,i)


        def whereClause(self):
            return self.getTypedRuleContext(SqlBaseParser.WhereClauseContext,0)


        def aggregationClause(self):
            return self.getTypedRuleContext(SqlBaseParser.AggregationClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(SqlBaseParser.HavingClauseContext,0)


        def windowClause(self):
            return self.getTypedRuleContext(SqlBaseParser.WindowClauseContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_fromStatementBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromStatementBody" ):
                listener.enterFromStatementBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromStatementBody" ):
                listener.exitFromStatementBody(self)




    def fromStatementBody(self):

        localctx = SqlBaseParser.FromStatementBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_fromStatementBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.selectClause()
            self.state = 346
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,25,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 343
                    self.lateralView() 
                self.state = 348
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,25,self._ctx)

            self.state = 350
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 349
                self.whereClause()


            self.state = 353
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
            if la_ == 1:
                self.state = 352
                self.aggregationClause()


            self.state = 356
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.state = 355
                self.havingClause()


            self.state = 359
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.state = 358
                self.windowClause()


            self.state = 361
            self.queryOrganization()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuerySpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_querySpecification

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegularQuerySpecificationContext(QuerySpecificationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.QuerySpecificationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def selectClause(self):
            return self.getTypedRuleContext(SqlBaseParser.SelectClauseContext,0)

        def fromClause(self):
            return self.getTypedRuleContext(SqlBaseParser.FromClauseContext,0)

        def lateralView(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.LateralViewContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.LateralViewContext,i)

        def whereClause(self):
            return self.getTypedRuleContext(SqlBaseParser.WhereClauseContext,0)

        def aggregationClause(self):
            return self.getTypedRuleContext(SqlBaseParser.AggregationClauseContext,0)

        def havingClause(self):
            return self.getTypedRuleContext(SqlBaseParser.HavingClauseContext,0)

        def windowClause(self):
            return self.getTypedRuleContext(SqlBaseParser.WindowClauseContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegularQuerySpecification" ):
                listener.enterRegularQuerySpecification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegularQuerySpecification" ):
                listener.exitRegularQuerySpecification(self)



    def querySpecification(self):

        localctx = SqlBaseParser.QuerySpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_querySpecification)
        try:
            localctx = SqlBaseParser.RegularQuerySpecificationContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.selectClause()
            self.state = 365
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 364
                self.fromClause()


            self.state = 370
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,31,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 367
                    self.lateralView() 
                self.state = 372
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,31,self._ctx)

            self.state = 374
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 373
                self.whereClause()


            self.state = 377
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.state = 376
                self.aggregationClause()


            self.state = 380
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 379
                self.havingClause()


            self.state = 383
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 382
                self.windowClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(SqlBaseParser.SELECT, 0)

        def namedExpressionSeq(self):
            return self.getTypedRuleContext(SqlBaseParser.NamedExpressionSeqContext,0)


        def setQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.SetQuantifierContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_selectClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelectClause" ):
                listener.enterSelectClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelectClause" ):
                listener.exitSelectClause(self)




    def selectClause(self):

        localctx = SqlBaseParser.SelectClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_selectClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.match(SqlBaseParser.SELECT)
            self.state = 387
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 386
                self.setQuantifier()


            self.state = 389
            self.namedExpressionSeq()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.AssignmentContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_assignmentList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentList" ):
                listener.enterAssignmentList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentList" ):
                listener.exitAssignmentList(self)




    def assignmentList(self):

        localctx = SqlBaseParser.AssignmentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_assignmentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.assignment()
            self.state = 396
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 392
                self.match(SqlBaseParser.T__1)
                self.state = 393
                self.assignment()
                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None # MultipartIdentifierContext
            self.value = None # ExpressionContext

        def EQ(self):
            return self.getToken(SqlBaseParser.EQ, 0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.MultipartIdentifierContext,0)


        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)




    def assignment(self):

        localctx = SqlBaseParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            localctx.key = self.multipartIdentifier()
            self.state = 400
            self.match(SqlBaseParser.EQ)
            self.state = 401
            localctx.value = self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_whereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhereClause" ):
                listener.enterWhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhereClause" ):
                listener.exitWhereClause(self)




    def whereClause(self):

        localctx = SqlBaseParser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.match(SqlBaseParser.WHERE)
            self.state = 404
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING(self):
            return self.getToken(SqlBaseParser.HAVING, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_havingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHavingClause" ):
                listener.enterHavingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHavingClause" ):
                listener.exitHavingClause(self)




    def havingClause(self):

        localctx = SqlBaseParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            self.match(SqlBaseParser.HAVING)
            self.state = 407
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.RelationContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.RelationContext,i)


        def lateralView(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.LateralViewContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.LateralViewContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFromClause" ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFromClause" ):
                listener.exitFromClause(self)




    def fromClause(self):

        localctx = SqlBaseParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_fromClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 409
            self.match(SqlBaseParser.FROM)
            self.state = 410
            self.relation()
            self.state = 415
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 411
                    self.match(SqlBaseParser.T__1)
                    self.state = 412
                    self.relation() 
                self.state = 417
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

            self.state = 421
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,39,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 418
                    self.lateralView() 
                self.state = 423
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,39,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._expression = None # ExpressionContext
            self.groupingExpressions = list() # of ExpressionContexts
            self.kind = None # Token

        def GROUP(self):
            return self.getToken(SqlBaseParser.GROUP, 0)

        def BY(self):
            return self.getToken(SqlBaseParser.BY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def WITH(self):
            return self.getToken(SqlBaseParser.WITH, 0)

        def SETS(self):
            return self.getToken(SqlBaseParser.SETS, 0)

        def groupingSet(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.GroupingSetContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.GroupingSetContext,i)


        def ROLLUP(self):
            return self.getToken(SqlBaseParser.ROLLUP, 0)

        def CUBE(self):
            return self.getToken(SqlBaseParser.CUBE, 0)

        def GROUPING(self):
            return self.getToken(SqlBaseParser.GROUPING, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_aggregationClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregationClause" ):
                listener.enterAggregationClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregationClause" ):
                listener.exitAggregationClause(self)




    def aggregationClause(self):

        localctx = SqlBaseParser.AggregationClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_aggregationClause)
        self._la = 0 # Token type
        try:
            self.state = 468
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 424
                self.match(SqlBaseParser.GROUP)
                self.state = 425
                self.match(SqlBaseParser.BY)
                self.state = 426
                localctx._expression = self.expression()
                localctx.groupingExpressions.append(localctx._expression)
                self.state = 431
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 427
                        self.match(SqlBaseParser.T__1)
                        self.state = 428
                        localctx._expression = self.expression()
                        localctx.groupingExpressions.append(localctx._expression) 
                    self.state = 433
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

                self.state = 451
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 434
                    self.match(SqlBaseParser.WITH)
                    self.state = 435
                    localctx.kind = self.match(SqlBaseParser.ROLLUP)

                elif la_ == 2:
                    self.state = 436
                    self.match(SqlBaseParser.WITH)
                    self.state = 437
                    localctx.kind = self.match(SqlBaseParser.CUBE)

                elif la_ == 3:
                    self.state = 438
                    localctx.kind = self.match(SqlBaseParser.GROUPING)
                    self.state = 439
                    self.match(SqlBaseParser.SETS)
                    self.state = 440
                    self.match(SqlBaseParser.T__2)
                    self.state = 441
                    self.groupingSet()
                    self.state = 446
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 442
                        self.match(SqlBaseParser.T__1)
                        self.state = 443
                        self.groupingSet()
                        self.state = 448
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 449
                    self.match(SqlBaseParser.T__3)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                self.match(SqlBaseParser.GROUP)
                self.state = 454
                self.match(SqlBaseParser.BY)
                self.state = 455
                localctx.kind = self.match(SqlBaseParser.GROUPING)
                self.state = 456
                self.match(SqlBaseParser.SETS)
                self.state = 457
                self.match(SqlBaseParser.T__2)
                self.state = 458
                self.groupingSet()
                self.state = 463
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 459
                    self.match(SqlBaseParser.T__1)
                    self.state = 460
                    self.groupingSet()
                    self.state = 465
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 466
                self.match(SqlBaseParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupingSetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_groupingSet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupingSet" ):
                listener.enterGroupingSet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupingSet" ):
                listener.exitGroupingSet(self)




    def groupingSet(self):

        localctx = SqlBaseParser.GroupingSetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_groupingSet)
        self._la = 0 # Token type
        try:
            self.state = 483
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 470
                self.match(SqlBaseParser.T__2)
                self.state = 479
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                if la_ == 1:
                    self.state = 471
                    self.expression()
                    self.state = 476
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 472
                        self.match(SqlBaseParser.T__1)
                        self.state = 473
                        self.expression()
                        self.state = 478
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 481
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 482
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LateralViewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tblName = None # IdentifierContext
            self._identifier = None # IdentifierContext
            self.colName = list() # of IdentifierContexts

        def LATERAL(self):
            return self.getToken(SqlBaseParser.LATERAL, 0)

        def VIEW(self):
            return self.getToken(SqlBaseParser.VIEW, 0)

        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def OUTER(self):
            return self.getToken(SqlBaseParser.OUTER, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_lateralView

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLateralView" ):
                listener.enterLateralView(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLateralView" ):
                listener.exitLateralView(self)




    def lateralView(self):

        localctx = SqlBaseParser.LateralViewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_lateralView)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            self.match(SqlBaseParser.LATERAL)
            self.state = 486
            self.match(SqlBaseParser.VIEW)
            self.state = 488
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 487
                self.match(SqlBaseParser.OUTER)


            self.state = 490
            self.qualifiedName()
            self.state = 491
            self.match(SqlBaseParser.T__2)
            self.state = 500
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.state = 492
                self.expression()
                self.state = 497
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 493
                    self.match(SqlBaseParser.T__1)
                    self.state = 494
                    self.expression()
                    self.state = 499
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 502
            self.match(SqlBaseParser.T__3)
            self.state = 503
            localctx.tblName = self.identifier()
            self.state = 515
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 505
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
                if la_ == 1:
                    self.state = 504
                    self.match(SqlBaseParser.AS)


                self.state = 507
                localctx._identifier = self.identifier()
                localctx.colName.append(localctx._identifier)
                self.state = 512
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,52,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 508
                        self.match(SqlBaseParser.T__1)
                        self.state = 509
                        localctx._identifier = self.identifier()
                        localctx.colName.append(localctx._identifier) 
                    self.state = 514
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,52,self._ctx)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetQuantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT(self):
            return self.getToken(SqlBaseParser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_setQuantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetQuantifier" ):
                listener.enterSetQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetQuantifier" ):
                listener.exitSetQuantifier(self)




    def setQuantifier(self):

        localctx = SqlBaseParser.SetQuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_setQuantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 517
            _la = self._input.LA(1)
            if not(_la==12 or _la==72):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlBaseParser.RelationPrimaryContext,0)


        def joinRelation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.JoinRelationContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.JoinRelationContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelation" ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelation" ):
                listener.exitRelation(self)




    def relation(self):

        localctx = SqlBaseParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 519
            self.relationPrimary()
            self.state = 523
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,54,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 520
                    self.joinRelation() 
                self.state = 525
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,54,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinRelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.right = None # RelationPrimaryContext

        def JOIN(self):
            return self.getToken(SqlBaseParser.JOIN, 0)

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlBaseParser.RelationPrimaryContext,0)


        def joinType(self):
            return self.getTypedRuleContext(SqlBaseParser.JoinTypeContext,0)


        def joinCriteria(self):
            return self.getTypedRuleContext(SqlBaseParser.JoinCriteriaContext,0)


        def NATURAL(self):
            return self.getToken(SqlBaseParser.NATURAL, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_joinRelation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinRelation" ):
                listener.enterJoinRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinRelation" ):
                listener.exitJoinRelation(self)




    def joinRelation(self):

        localctx = SqlBaseParser.JoinRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_joinRelation)
        try:
            self.state = 537
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [16, 52, 99, 114, 123, 129, 194, 205]:
                self.enterOuterAlt(localctx, 1)
                self.state = 526
                self.joinType()
                self.state = 527
                self.match(SqlBaseParser.JOIN)
                self.state = 528
                localctx.right = self.relationPrimary()
                self.state = 530
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
                if la_ == 1:
                    self.state = 529
                    self.joinCriteria()


                pass
            elif token in [149]:
                self.enterOuterAlt(localctx, 2)
                self.state = 532
                self.match(SqlBaseParser.NATURAL)
                self.state = 533
                self.joinType()
                self.state = 534
                self.match(SqlBaseParser.JOIN)
                self.state = 535
                localctx.right = self.relationPrimary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INNER(self):
            return self.getToken(SqlBaseParser.INNER, 0)

        def CROSS(self):
            return self.getToken(SqlBaseParser.CROSS, 0)

        def LEFT(self):
            return self.getToken(SqlBaseParser.LEFT, 0)

        def OUTER(self):
            return self.getToken(SqlBaseParser.OUTER, 0)

        def SEMI(self):
            return self.getToken(SqlBaseParser.SEMI, 0)

        def RIGHT(self):
            return self.getToken(SqlBaseParser.RIGHT, 0)

        def FULL(self):
            return self.getToken(SqlBaseParser.FULL, 0)

        def ANTI(self):
            return self.getToken(SqlBaseParser.ANTI, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_joinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinType" ):
                listener.enterJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinType" ):
                listener.exitJoinType(self)




    def joinType(self):

        localctx = SqlBaseParser.JoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_joinType)
        self._la = 0 # Token type
        try:
            self.state = 563
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==114:
                    self.state = 539
                    self.match(SqlBaseParser.INNER)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 542
                self.match(SqlBaseParser.CROSS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 543
                self.match(SqlBaseParser.LEFT)
                self.state = 545
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==162:
                    self.state = 544
                    self.match(SqlBaseParser.OUTER)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 548
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==129:
                    self.state = 547
                    self.match(SqlBaseParser.LEFT)


                self.state = 550
                self.match(SqlBaseParser.SEMI)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 551
                self.match(SqlBaseParser.RIGHT)
                self.state = 553
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==162:
                    self.state = 552
                    self.match(SqlBaseParser.OUTER)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 555
                self.match(SqlBaseParser.FULL)
                self.state = 557
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==162:
                    self.state = 556
                    self.match(SqlBaseParser.OUTER)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 560
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==129:
                    self.state = 559
                    self.match(SqlBaseParser.LEFT)


                self.state = 562
                self.match(SqlBaseParser.ANTI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinCriteriaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(SqlBaseParser.ON, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def USING(self):
            return self.getToken(SqlBaseParser.USING, 0)

        def identifierList(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_joinCriteria

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJoinCriteria" ):
                listener.enterJoinCriteria(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJoinCriteria" ):
                listener.exitJoinCriteria(self)




    def joinCriteria(self):

        localctx = SqlBaseParser.JoinCriteriaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_joinCriteria)
        try:
            self.state = 569
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [155]:
                self.enterOuterAlt(localctx, 1)
                self.state = 565
                self.match(SqlBaseParser.ON)
                self.state = 566
                self.booleanExpression(0)
                pass
            elif token in [253]:
                self.enterOuterAlt(localctx, 2)
                self.state = 567
                self.match(SqlBaseParser.USING)
                self.state = 568
                self.identifierList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierSeq(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierSeqContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_identifierList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierList" ):
                listener.enterIdentifierList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierList" ):
                listener.exitIdentifierList(self)




    def identifierList(self):

        localctx = SqlBaseParser.IdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_identifierList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 571
            self.match(SqlBaseParser.T__2)
            self.state = 572
            self.identifierSeq()
            self.state = 573
            self.match(SqlBaseParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierSeqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._errorCapturingIdentifier = None # ErrorCapturingIdentifierContext
            self.ident = list() # of ErrorCapturingIdentifierContexts

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_identifierSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierSeq" ):
                listener.enterIdentifierSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierSeq" ):
                listener.exitIdentifierSeq(self)




    def identifierSeq(self):

        localctx = SqlBaseParser.IdentifierSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_identifierSeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 575
            localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
            localctx.ident.append(localctx._errorCapturingIdentifier)
            self.state = 580
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 576
                self.match(SqlBaseParser.T__1)
                self.state = 577
                localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
                localctx.ident.append(localctx._errorCapturingIdentifier)
                self.state = 582
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderedIdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.OrderedIdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.OrderedIdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_orderedIdentifierList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderedIdentifierList" ):
                listener.enterOrderedIdentifierList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderedIdentifierList" ):
                listener.exitOrderedIdentifierList(self)




    def orderedIdentifierList(self):

        localctx = SqlBaseParser.OrderedIdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_orderedIdentifierList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 583
            self.match(SqlBaseParser.T__2)
            self.state = 584
            self.orderedIdentifier()
            self.state = 589
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 585
                self.match(SqlBaseParser.T__1)
                self.state = 586
                self.orderedIdentifier()
                self.state = 591
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 592
            self.match(SqlBaseParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ident = None # ErrorCapturingIdentifierContext
            self.ordering = None # Token

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,0)


        def ASC(self):
            return self.getToken(SqlBaseParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlBaseParser.DESC, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_orderedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderedIdentifier" ):
                listener.enterOrderedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderedIdentifier" ):
                listener.exitOrderedIdentifier(self)




    def orderedIdentifier(self):

        localctx = SqlBaseParser.OrderedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_orderedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 594
            localctx.ident = self.errorCapturingIdentifier()
            self.state = 596
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21 or _la==67:
                self.state = 595
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==21 or _la==67):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_relationPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TableValuedFunctionContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionTable(self):
            return self.getTypedRuleContext(SqlBaseParser.FunctionTableContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableValuedFunction" ):
                listener.enterTableValuedFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableValuedFunction" ):
                listener.exitTableValuedFunction(self)


    class AliasedRelationContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def relation(self):
            return self.getTypedRuleContext(SqlBaseParser.RelationContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(SqlBaseParser.TableAliasContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasedRelation" ):
                listener.enterAliasedRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasedRelation" ):
                listener.exitAliasedRelation(self)


    class AliasedQueryContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(SqlBaseParser.TableAliasContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAliasedQuery" ):
                listener.enterAliasedQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAliasedQuery" ):
                listener.exitAliasedQuery(self)


    class TableNameContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.MultipartIdentifierContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(SqlBaseParser.TableAliasContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableName" ):
                listener.enterTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableName" ):
                listener.exitTableName(self)



    def relationPrimary(self):

        localctx = SqlBaseParser.RelationPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_relationPrimary)
        try:
            self.state = 612
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.TableNameContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 598
                self.multipartIdentifier()
                self.state = 599
                self.tableAlias()
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.AliasedQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 601
                self.match(SqlBaseParser.T__2)
                self.state = 602
                self.query()
                self.state = 603
                self.match(SqlBaseParser.T__3)
                self.state = 604
                self.tableAlias()
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.AliasedRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 606
                self.match(SqlBaseParser.T__2)
                self.state = 607
                self.relation()
                self.state = 608
                self.match(SqlBaseParser.T__3)
                self.state = 609
                self.tableAlias()
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.TableValuedFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 611
                self.functionTable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.funcName = None # ErrorCapturingIdentifierContext

        def tableAlias(self):
            return self.getTypedRuleContext(SqlBaseParser.TableAliasContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_functionTable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionTable" ):
                listener.enterFunctionTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionTable" ):
                listener.exitFunctionTable(self)




    def functionTable(self):

        localctx = SqlBaseParser.FunctionTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_functionTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 614
            localctx.funcName = self.errorCapturingIdentifier()
            self.state = 615
            self.match(SqlBaseParser.T__2)
            self.state = 624
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 616
                self.expression()
                self.state = 621
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 617
                    self.match(SqlBaseParser.T__1)
                    self.state = 618
                    self.expression()
                    self.state = 623
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 626
            self.match(SqlBaseParser.T__3)
            self.state = 627
            self.tableAlias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableAliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def strictIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.StrictIdentifierContext,0)


        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def identifierList(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_tableAlias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableAlias" ):
                listener.enterTableAlias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableAlias" ):
                listener.exitTableAlias(self)




    def tableAlias(self):

        localctx = SqlBaseParser.TableAliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_tableAlias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 636
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 630
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
                if la_ == 1:
                    self.state = 629
                    self.match(SqlBaseParser.AS)


                self.state = 632
                self.strictIdentifier()
                self.state = 634
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
                if la_ == 1:
                    self.state = 633
                    self.identifierList()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultipartIdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.MultipartIdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_multipartIdentifierList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultipartIdentifierList" ):
                listener.enterMultipartIdentifierList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultipartIdentifierList" ):
                listener.exitMultipartIdentifierList(self)




    def multipartIdentifierList(self):

        localctx = SqlBaseParser.MultipartIdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_multipartIdentifierList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.multipartIdentifier()
            self.state = 643
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 639
                self.match(SqlBaseParser.T__1)
                self.state = 640
                self.multipartIdentifier()
                self.state = 645
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultipartIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._errorCapturingIdentifier = None # ErrorCapturingIdentifierContext
            self.parts = list() # of ErrorCapturingIdentifierContexts

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_multipartIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultipartIdentifier" ):
                listener.enterMultipartIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultipartIdentifier" ):
                listener.exitMultipartIdentifier(self)




    def multipartIdentifier(self):

        localctx = SqlBaseParser.MultipartIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_multipartIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
            localctx.parts.append(localctx._errorCapturingIdentifier)
            self.state = 651
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,75,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 647
                    self.match(SqlBaseParser.T__4)
                    self.state = 648
                    localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
                    localctx.parts.append(localctx._errorCapturingIdentifier) 
                self.state = 653
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,75,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.db = None # ErrorCapturingIdentifierContext
            self.table = None # ErrorCapturingIdentifierContext

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_tableIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTableIdentifier" ):
                listener.enterTableIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTableIdentifier" ):
                listener.exitTableIdentifier(self)




    def tableIdentifier(self):

        localctx = SqlBaseParser.TableIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_tableIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 657
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
            if la_ == 1:
                self.state = 654
                localctx.db = self.errorCapturingIdentifier()
                self.state = 655
                self.match(SqlBaseParser.T__4)


            self.state = 659
            localctx.table = self.errorCapturingIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.db = None # ErrorCapturingIdentifierContext
            self.function = None # ErrorCapturingIdentifierContext

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_functionIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionIdentifier" ):
                listener.enterFunctionIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionIdentifier" ):
                listener.exitFunctionIdentifier(self)




    def functionIdentifier(self):

        localctx = SqlBaseParser.FunctionIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_functionIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 664
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
            if la_ == 1:
                self.state = 661
                localctx.db = self.errorCapturingIdentifier()
                self.state = 662
                self.match(SqlBaseParser.T__4)


            self.state = 666
            localctx.function = self.errorCapturingIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # ErrorCapturingIdentifierContext

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def identifierList(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierListContext,0)


        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_namedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedExpression" ):
                listener.enterNamedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedExpression" ):
                listener.exitNamedExpression(self)




    def namedExpression(self):

        localctx = SqlBaseParser.NamedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_namedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            self.expression()
            self.state = 676
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.state = 670
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
                if la_ == 1:
                    self.state = 669
                    self.match(SqlBaseParser.AS)


                self.state = 674
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                if la_ == 1:
                    self.state = 672
                    localctx.name = self.errorCapturingIdentifier()
                    pass

                elif la_ == 2:
                    self.state = 673
                    self.identifierList()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionSeqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.NamedExpressionContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_namedExpressionSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedExpressionSeq" ):
                listener.enterNamedExpressionSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedExpressionSeq" ):
                listener.exitNamedExpressionSeq(self)




    def namedExpressionSeq(self):

        localctx = SqlBaseParser.NamedExpressionSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_namedExpressionSeq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self.namedExpression()
            self.state = 683
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,81,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 679
                    self.match(SqlBaseParser.T__1)
                    self.state = 680
                    self.namedExpression() 
                self.state = 685
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = SqlBaseParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_booleanExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class LogicalNotContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalNot" ):
                listener.enterLogicalNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalNot" ):
                listener.exitLogicalNot(self)


    class PredicatedContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)

        def predicate(self):
            return self.getTypedRuleContext(SqlBaseParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicated" ):
                listener.enterPredicated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicated" ):
                listener.exitPredicated(self)


    class ExistsContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXISTS(self):
            return self.getToken(SqlBaseParser.EXISTS, 0)
        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExists" ):
                listener.enterExists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExists" ):
                listener.exitExists(self)


    class LogicalBinaryContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.operator = None # Token
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,i)

        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)
        def OR(self):
            return self.getToken(SqlBaseParser.OR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogicalBinary" ):
                listener.enterLogicalBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogicalBinary" ):
                listener.exitLogicalBinary(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 98
        self.enterRecursionRule(localctx, 98, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.LogicalNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 689
                self.match(SqlBaseParser.NOT)
                self.state = 690
                self.booleanExpression(5)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.ExistsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 691
                self.match(SqlBaseParser.EXISTS)
                self.state = 692
                self.match(SqlBaseParser.T__2)
                self.state = 693
                self.query()
                self.state = 694
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.PredicatedContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 696
                self.valueExpression(0)
                self.state = 698
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                if la_ == 1:
                    self.state = 697
                    self.predicate()


                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 710
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,85,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 708
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                    if la_ == 1:
                        localctx = SqlBaseParser.LogicalBinaryContext(self, SqlBaseParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 702
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 703
                        localctx.operator = self.match(SqlBaseParser.AND)
                        self.state = 704
                        localctx.right = self.booleanExpression(3)
                        pass

                    elif la_ == 2:
                        localctx = SqlBaseParser.LogicalBinaryContext(self, SqlBaseParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 705
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 706
                        localctx.operator = self.match(SqlBaseParser.OR)
                        self.state = 707
                        localctx.right = self.booleanExpression(2)
                        pass

             
                self.state = 712
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kind = None # Token
            self.lower = None # ValueExpressionContext
            self.upper = None # ValueExpressionContext
            self.pattern = None # ValueExpressionContext
            self.quantifier = None # Token
            self.escapeChar = None # Token
            self.right = None # ValueExpressionContext

        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)

        def BETWEEN(self):
            return self.getToken(SqlBaseParser.BETWEEN, 0)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)


        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def IN(self):
            return self.getToken(SqlBaseParser.IN, 0)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def RLIKE(self):
            return self.getToken(SqlBaseParser.RLIKE, 0)

        def LIKE(self):
            return self.getToken(SqlBaseParser.LIKE, 0)

        def ANY(self):
            return self.getToken(SqlBaseParser.ANY, 0)

        def SOME(self):
            return self.getToken(SqlBaseParser.SOME, 0)

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def ESCAPE(self):
            return self.getToken(SqlBaseParser.ESCAPE, 0)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def IS(self):
            return self.getToken(SqlBaseParser.IS, 0)

        def NULL(self):
            return self.getToken(SqlBaseParser.NULL, 0)

        def TRUE(self):
            return self.getToken(SqlBaseParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SqlBaseParser.FALSE, 0)

        def UNKNOWN(self):
            return self.getToken(SqlBaseParser.UNKNOWN, 0)

        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)

        def DISTINCT(self):
            return self.getToken(SqlBaseParser.DISTINCT, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate" ):
                listener.enterPredicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate" ):
                listener.exitPredicate(self)




    def predicate(self):

        localctx = SqlBaseParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.state = 795
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 714
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 713
                    self.match(SqlBaseParser.NOT)


                self.state = 716
                localctx.kind = self.match(SqlBaseParser.BETWEEN)
                self.state = 717
                localctx.lower = self.valueExpression(0)
                self.state = 718
                self.match(SqlBaseParser.AND)
                self.state = 719
                localctx.upper = self.valueExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 722
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 721
                    self.match(SqlBaseParser.NOT)


                self.state = 724
                localctx.kind = self.match(SqlBaseParser.IN)
                self.state = 725
                self.match(SqlBaseParser.T__2)
                self.state = 726
                self.expression()
                self.state = 731
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==2:
                    self.state = 727
                    self.match(SqlBaseParser.T__1)
                    self.state = 728
                    self.expression()
                    self.state = 733
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 734
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 737
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 736
                    self.match(SqlBaseParser.NOT)


                self.state = 739
                localctx.kind = self.match(SqlBaseParser.IN)
                self.state = 740
                self.match(SqlBaseParser.T__2)
                self.state = 741
                self.query()
                self.state = 742
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 745
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 744
                    self.match(SqlBaseParser.NOT)


                self.state = 747
                localctx.kind = self.match(SqlBaseParser.RLIKE)
                self.state = 748
                localctx.pattern = self.valueExpression(0)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 750
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 749
                    self.match(SqlBaseParser.NOT)


                self.state = 752
                localctx.kind = self.match(SqlBaseParser.LIKE)
                self.state = 753
                localctx.quantifier = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==12 or _la==17 or _la==215):
                    localctx.quantifier = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 767
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                if la_ == 1:
                    self.state = 754
                    self.match(SqlBaseParser.T__2)
                    self.state = 755
                    self.match(SqlBaseParser.T__3)
                    pass

                elif la_ == 2:
                    self.state = 756
                    self.match(SqlBaseParser.T__2)
                    self.state = 757
                    self.expression()
                    self.state = 762
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 758
                        self.match(SqlBaseParser.T__1)
                        self.state = 759
                        self.expression()
                        self.state = 764
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 765
                    self.match(SqlBaseParser.T__3)
                    pass


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 770
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 769
                    self.match(SqlBaseParser.NOT)


                self.state = 772
                localctx.kind = self.match(SqlBaseParser.LIKE)
                self.state = 773
                localctx.pattern = self.valueExpression(0)
                self.state = 776
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
                if la_ == 1:
                    self.state = 774
                    self.match(SqlBaseParser.ESCAPE)
                    self.state = 775
                    localctx.escapeChar = self.match(SqlBaseParser.STRING)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 778
                self.match(SqlBaseParser.IS)
                self.state = 780
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 779
                    self.match(SqlBaseParser.NOT)


                self.state = 782
                localctx.kind = self.match(SqlBaseParser.NULL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 783
                self.match(SqlBaseParser.IS)
                self.state = 785
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 784
                    self.match(SqlBaseParser.NOT)


                self.state = 787
                localctx.kind = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==87 or _la==239 or _la==247):
                    localctx.kind = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 788
                self.match(SqlBaseParser.IS)
                self.state = 790
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==151:
                    self.state = 789
                    self.match(SqlBaseParser.NOT)


                self.state = 792
                localctx.kind = self.match(SqlBaseParser.DISTINCT)
                self.state = 793
                self.match(SqlBaseParser.FROM)
                self.state = 794
                localctx.right = self.valueExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_valueExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ValueExpressionDefaultContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.PrimaryExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValueExpressionDefault" ):
                listener.enterValueExpressionDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValueExpressionDefault" ):
                listener.exitValueExpressionDefault(self)


    class ComparisonContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.left = None # ValueExpressionContext
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlBaseParser.ComparisonOperatorContext,0)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)


    class ArithmeticBinaryContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.left = None # ValueExpressionContext
            self.operator = None # Token
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)
        def SLASH(self):
            return self.getToken(SqlBaseParser.SLASH, 0)
        def PERCENT(self):
            return self.getToken(SqlBaseParser.PERCENT, 0)
        def DIV(self):
            return self.getToken(SqlBaseParser.DIV, 0)
        def PLUS(self):
            return self.getToken(SqlBaseParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)
        def CONCAT_PIPE(self):
            return self.getToken(SqlBaseParser.CONCAT_PIPE, 0)
        def AMPERSAND(self):
            return self.getToken(SqlBaseParser.AMPERSAND, 0)
        def HAT(self):
            return self.getToken(SqlBaseParser.HAT, 0)
        def PIPE(self):
            return self.getToken(SqlBaseParser.PIPE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticBinary" ):
                listener.enterArithmeticBinary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticBinary" ):
                listener.exitArithmeticBinary(self)


    class ArithmeticUnaryContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ValueExpressionContext
            super().__init__(parser)
            self.operator = None # Token
            self.copyFrom(ctx)

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)

        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)
        def PLUS(self):
            return self.getToken(SqlBaseParser.PLUS, 0)
        def TILDE(self):
            return self.getToken(SqlBaseParser.TILDE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticUnary" ):
                listener.enterArithmeticUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticUnary" ):
                listener.exitArithmeticUnary(self)



    def valueExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.ValueExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 102
        self.enterRecursionRule(localctx, 102, self.RULE_valueExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 801
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.ValueExpressionDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 798
                self.primaryExpression(0)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.ArithmeticUnaryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 799
                localctx.operator = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & 67) != 0)):
                    localctx.operator = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 800
                self.valueExpression(7)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 824
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,102,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 822
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
                    if la_ == 1:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 803
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 804
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & 15) != 0)):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 805
                        localctx.right = self.valueExpression(7)
                        pass

                    elif la_ == 2:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 806
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 807
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & 515) != 0)):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 808
                        localctx.right = self.valueExpression(6)
                        pass

                    elif la_ == 3:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 809
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 810
                        localctx.operator = self.match(SqlBaseParser.AMPERSAND)
                        self.state = 811
                        localctx.right = self.valueExpression(5)
                        pass

                    elif la_ == 4:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 812
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 813
                        localctx.operator = self.match(SqlBaseParser.HAT)
                        self.state = 814
                        localctx.right = self.valueExpression(4)
                        pass

                    elif la_ == 5:
                        localctx = SqlBaseParser.ArithmeticBinaryContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 815
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 816
                        localctx.operator = self.match(SqlBaseParser.PIPE)
                        self.state = 817
                        localctx.right = self.valueExpression(3)
                        pass

                    elif la_ == 6:
                        localctx = SqlBaseParser.ComparisonContext(self, SqlBaseParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 818
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 819
                        self.comparisonOperator()
                        self.state = 820
                        localctx.right = self.valueExpression(2)
                        pass

             
                self.state = 826
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,102,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class StructContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self._namedExpression = None # NamedExpressionContext
            self.argument = list() # of NamedExpressionContexts
            self.copyFrom(ctx)

        def STRUCT(self):
            return self.getToken(SqlBaseParser.STRUCT, 0)
        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.NamedExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStruct" ):
                listener.enterStruct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStruct" ):
                listener.exitStruct(self)


    class DereferenceContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.base = None # PrimaryExpressionContext
            self.fieldName = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDereference" ):
                listener.enterDereference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDereference" ):
                listener.exitDereference(self)


    class SimpleCaseContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.value = None # ExpressionContext
            self.elseExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def CASE(self):
            return self.getToken(SqlBaseParser.CASE, 0)
        def END(self):
            return self.getToken(SqlBaseParser.END, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)

        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.WhenClauseContext,i)

        def ELSE(self):
            return self.getToken(SqlBaseParser.ELSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleCase" ):
                listener.enterSimpleCase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleCase" ):
                listener.exitSimpleCase(self)


    class ColumnReferenceContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumnReference" ):
                listener.enterColumnReference(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumnReference" ):
                listener.exitColumnReference(self)


    class RowConstructorContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.NamedExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRowConstructor" ):
                listener.enterRowConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRowConstructor" ):
                listener.exitRowConstructor(self)


    class LastContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAST(self):
            return self.getToken(SqlBaseParser.LAST, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)

        def IGNORE(self):
            return self.getToken(SqlBaseParser.IGNORE, 0)
        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLast" ):
                listener.enterLast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLast" ):
                listener.exitLast(self)


    class StarContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)
        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStar" ):
                listener.enterStar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStar" ):
                listener.exitStar(self)


    class OverlayContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.initial_value = None # ValueExpressionContext
            self.replace = None # ValueExpressionContext
            self.position = None # ValueExpressionContext
            self.length = None # ValueExpressionContext
            self.copyFrom(ctx)

        def OVERLAY(self):
            return self.getToken(SqlBaseParser.OVERLAY, 0)
        def PLACING(self):
            return self.getToken(SqlBaseParser.PLACING, 0)
        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def FOR(self):
            return self.getToken(SqlBaseParser.FOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOverlay" ):
                listener.enterOverlay(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOverlay" ):
                listener.exitOverlay(self)


    class SubscriptContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.value = None # PrimaryExpressionContext
            self.index = None # ValueExpressionContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.PrimaryExpressionContext,0)

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubscript" ):
                listener.enterSubscript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubscript" ):
                listener.exitSubscript(self)


    class SubqueryExpressionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(SqlBaseParser.QueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubqueryExpression" ):
                listener.enterSubqueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubqueryExpression" ):
                listener.exitSubqueryExpression(self)


    class SubstringContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.superstr = None # ValueExpressionContext
            self.pos = None # ValueExpressionContext
            self.length = None # ValueExpressionContext
            self.copyFrom(ctx)

        def SUBSTR(self):
            return self.getToken(SqlBaseParser.SUBSTR, 0)
        def SUBSTRING(self):
            return self.getToken(SqlBaseParser.SUBSTRING, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)
        def FOR(self):
            return self.getToken(SqlBaseParser.FOR, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubstring" ):
                listener.enterSubstring(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubstring" ):
                listener.exitSubstring(self)


    class CurrentDatetimeContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def CURRENT_DATE(self):
            return self.getToken(SqlBaseParser.CURRENT_DATE, 0)
        def CURRENT_TIMESTAMP(self):
            return self.getToken(SqlBaseParser.CURRENT_TIMESTAMP, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCurrentDatetime" ):
                listener.enterCurrentDatetime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCurrentDatetime" ):
                listener.exitCurrentDatetime(self)


    class CastContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CAST(self):
            return self.getToken(SqlBaseParser.CAST, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)

        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)
        def dataType(self):
            return self.getTypedRuleContext(SqlBaseParser.DataTypeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)


    class ConstantDefaultContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def constant(self):
            return self.getTypedRuleContext(SqlBaseParser.ConstantContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantDefault" ):
                listener.enterConstantDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantDefault" ):
                listener.exitConstantDefault(self)


    class LambdaContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLambda" ):
                listener.enterLambda(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLambda" ):
                listener.exitLambda(self)


    class ParenthesizedExpressionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)


    class ExtractContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.field = None # IdentifierContext
            self.source = None # ValueExpressionContext
            self.copyFrom(ctx)

        def EXTRACT(self):
            return self.getToken(SqlBaseParser.EXTRACT, 0)
        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)

        def valueExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtract" ):
                listener.enterExtract(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtract" ):
                listener.exitExtract(self)


    class TrimContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.trimOption = None # Token
            self.trimStr = None # ValueExpressionContext
            self.srcStr = None # ValueExpressionContext
            self.copyFrom(ctx)

        def TRIM(self):
            return self.getToken(SqlBaseParser.TRIM, 0)
        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)

        def BOTH(self):
            return self.getToken(SqlBaseParser.BOTH, 0)
        def LEADING(self):
            return self.getToken(SqlBaseParser.LEADING, 0)
        def TRAILING(self):
            return self.getToken(SqlBaseParser.TRAILING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrim" ):
                listener.enterTrim(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrim" ):
                listener.exitTrim(self)


    class FunctionCallContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self._expression = None # ExpressionContext
            self.argument = list() # of ExpressionContexts
            self.where = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def functionName(self):
            return self.getTypedRuleContext(SqlBaseParser.FunctionNameContext,0)

        def FILTER(self):
            return self.getToken(SqlBaseParser.FILTER, 0)
        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)
        def OVER(self):
            return self.getToken(SqlBaseParser.OVER, 0)
        def windowSpec(self):
            return self.getTypedRuleContext(SqlBaseParser.WindowSpecContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanExpressionContext,0)

        def setQuantifier(self):
            return self.getTypedRuleContext(SqlBaseParser.SetQuantifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)


    class SearchedCaseContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.elseExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def CASE(self):
            return self.getToken(SqlBaseParser.CASE, 0)
        def END(self):
            return self.getToken(SqlBaseParser.END, 0)
        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.WhenClauseContext,i)

        def ELSE(self):
            return self.getToken(SqlBaseParser.ELSE, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSearchedCase" ):
                listener.enterSearchedCase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSearchedCase" ):
                listener.exitSearchedCase(self)


    class PositionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.substr = None # ValueExpressionContext
            self.superstr = None # ValueExpressionContext
            self.copyFrom(ctx)

        def POSITION(self):
            return self.getToken(SqlBaseParser.POSITION, 0)
        def IN(self):
            return self.getToken(SqlBaseParser.IN, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ValueExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition" ):
                listener.enterPosition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition" ):
                listener.exitPosition(self)


    class FirstContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FIRST(self):
            return self.getToken(SqlBaseParser.FIRST, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)

        def IGNORE(self):
            return self.getToken(SqlBaseParser.IGNORE, 0)
        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFirst" ):
                listener.enterFirst(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFirst" ):
                listener.exitFirst(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlBaseParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 104
        self.enterRecursionRule(localctx, 104, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1011
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.CurrentDatetimeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 828
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==55 or _la==57):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.SearchedCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 829
                self.match(SqlBaseParser.CASE)
                self.state = 831 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 830
                    self.whenClause()
                    self.state = 833 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==257):
                        break

                self.state = 837
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==75:
                    self.state = 835
                    self.match(SqlBaseParser.ELSE)
                    self.state = 836
                    localctx.elseExpression = self.expression()


                self.state = 839
                self.match(SqlBaseParser.END)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.SimpleCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 841
                self.match(SqlBaseParser.CASE)
                self.state = 842
                localctx.value = self.expression()
                self.state = 844 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 843
                    self.whenClause()
                    self.state = 846 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==257):
                        break

                self.state = 850
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==75:
                    self.state = 848
                    self.match(SqlBaseParser.ELSE)
                    self.state = 849
                    localctx.elseExpression = self.expression()


                self.state = 852
                self.match(SqlBaseParser.END)
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.CastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 854
                self.match(SqlBaseParser.CAST)
                self.state = 855
                self.match(SqlBaseParser.T__2)
                self.state = 856
                self.expression()
                self.state = 857
                self.match(SqlBaseParser.AS)
                self.state = 858
                self.dataType()
                self.state = 859
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 5:
                localctx = SqlBaseParser.StructContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 861
                self.match(SqlBaseParser.STRUCT)
                self.state = 862
                self.match(SqlBaseParser.T__2)
                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 863
                    localctx._namedExpression = self.namedExpression()
                    localctx.argument.append(localctx._namedExpression)
                    self.state = 868
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 864
                        self.match(SqlBaseParser.T__1)
                        self.state = 865
                        localctx._namedExpression = self.namedExpression()
                        localctx.argument.append(localctx._namedExpression)
                        self.state = 870
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 873
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 6:
                localctx = SqlBaseParser.FirstContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 874
                self.match(SqlBaseParser.FIRST)
                self.state = 875
                self.match(SqlBaseParser.T__2)
                self.state = 876
                self.expression()
                self.state = 879
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==109:
                    self.state = 877
                    self.match(SqlBaseParser.IGNORE)
                    self.state = 878
                    self.match(SqlBaseParser.NULLS)


                self.state = 881
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 7:
                localctx = SqlBaseParser.LastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 883
                self.match(SqlBaseParser.LAST)
                self.state = 884
                self.match(SqlBaseParser.T__2)
                self.state = 885
                self.expression()
                self.state = 888
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==109:
                    self.state = 886
                    self.match(SqlBaseParser.IGNORE)
                    self.state = 887
                    self.match(SqlBaseParser.NULLS)


                self.state = 890
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 8:
                localctx = SqlBaseParser.PositionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 892
                self.match(SqlBaseParser.POSITION)
                self.state = 893
                self.match(SqlBaseParser.T__2)
                self.state = 894
                localctx.substr = self.valueExpression(0)
                self.state = 895
                self.match(SqlBaseParser.IN)
                self.state = 896
                localctx.superstr = self.valueExpression(0)
                self.state = 897
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 9:
                localctx = SqlBaseParser.ConstantDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 899
                self.constant()
                pass

            elif la_ == 10:
                localctx = SqlBaseParser.StarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 900
                self.match(SqlBaseParser.ASTERISK)
                pass

            elif la_ == 11:
                localctx = SqlBaseParser.StarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 901
                self.qualifiedName()
                self.state = 902
                self.match(SqlBaseParser.T__4)
                self.state = 903
                self.match(SqlBaseParser.ASTERISK)
                pass

            elif la_ == 12:
                localctx = SqlBaseParser.RowConstructorContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 905
                self.match(SqlBaseParser.T__2)
                self.state = 906
                self.namedExpression()
                self.state = 909 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 907
                    self.match(SqlBaseParser.T__1)
                    self.state = 908
                    self.namedExpression()
                    self.state = 911 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==2):
                        break

                self.state = 913
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 13:
                localctx = SqlBaseParser.SubqueryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 915
                self.match(SqlBaseParser.T__2)
                self.state = 916
                self.query()
                self.state = 917
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 14:
                localctx = SqlBaseParser.FunctionCallContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 919
                self.functionName()
                self.state = 920
                self.match(SqlBaseParser.T__2)
                self.state = 932
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
                if la_ == 1:
                    self.state = 922
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                    if la_ == 1:
                        self.state = 921
                        self.setQuantifier()


                    self.state = 924
                    localctx._expression = self.expression()
                    localctx.argument.append(localctx._expression)
                    self.state = 929
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 925
                        self.match(SqlBaseParser.T__1)
                        self.state = 926
                        localctx._expression = self.expression()
                        localctx.argument.append(localctx._expression)
                        self.state = 931
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 934
                self.match(SqlBaseParser.T__3)
                self.state = 941
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
                if la_ == 1:
                    self.state = 935
                    self.match(SqlBaseParser.FILTER)
                    self.state = 936
                    self.match(SqlBaseParser.T__2)
                    self.state = 937
                    self.match(SqlBaseParser.WHERE)
                    self.state = 938
                    localctx.where = self.booleanExpression(0)
                    self.state = 939
                    self.match(SqlBaseParser.T__3)


                self.state = 945
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                if la_ == 1:
                    self.state = 943
                    self.match(SqlBaseParser.OVER)
                    self.state = 944
                    self.windowSpec()


                pass

            elif la_ == 15:
                localctx = SqlBaseParser.LambdaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 947
                self.identifier()
                self.state = 948
                self.match(SqlBaseParser.T__5)
                self.state = 949
                self.expression()
                pass

            elif la_ == 16:
                localctx = SqlBaseParser.LambdaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 951
                self.match(SqlBaseParser.T__2)
                self.state = 952
                self.identifier()
                self.state = 955 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 953
                    self.match(SqlBaseParser.T__1)
                    self.state = 954
                    self.identifier()
                    self.state = 957 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==2):
                        break

                self.state = 959
                self.match(SqlBaseParser.T__3)
                self.state = 960
                self.match(SqlBaseParser.T__5)
                self.state = 961
                self.expression()
                pass

            elif la_ == 17:
                localctx = SqlBaseParser.ColumnReferenceContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 963
                self.identifier()
                pass

            elif la_ == 18:
                localctx = SqlBaseParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 964
                self.match(SqlBaseParser.T__2)
                self.state = 965
                self.expression()
                self.state = 966
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 19:
                localctx = SqlBaseParser.ExtractContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 968
                self.match(SqlBaseParser.EXTRACT)
                self.state = 969
                self.match(SqlBaseParser.T__2)
                self.state = 970
                localctx.field = self.identifier()
                self.state = 971
                self.match(SqlBaseParser.FROM)
                self.state = 972
                localctx.source = self.valueExpression(0)
                self.state = 973
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 20:
                localctx = SqlBaseParser.SubstringContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 975
                _la = self._input.LA(1)
                if not(_la==223 or _la==224):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 976
                self.match(SqlBaseParser.T__2)
                self.state = 977
                localctx.superstr = self.valueExpression(0)
                self.state = 978
                _la = self._input.LA(1)
                if not(_la==2 or _la==98):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 979
                localctx.pos = self.valueExpression(0)
                self.state = 982
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==2 or _la==94:
                    self.state = 980
                    _la = self._input.LA(1)
                    if not(_la==2 or _la==94):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 981
                    localctx.length = self.valueExpression(0)


                self.state = 984
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 21:
                localctx = SqlBaseParser.TrimContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 986
                self.match(SqlBaseParser.TRIM)
                self.state = 987
                self.match(SqlBaseParser.T__2)
                self.state = 989
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
                if la_ == 1:
                    self.state = 988
                    localctx.trimOption = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==25 or _la==128 or _la==234):
                        localctx.trimOption = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 992
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                if la_ == 1:
                    self.state = 991
                    localctx.trimStr = self.valueExpression(0)


                self.state = 994
                self.match(SqlBaseParser.FROM)
                self.state = 995
                localctx.srcStr = self.valueExpression(0)
                self.state = 996
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 22:
                localctx = SqlBaseParser.OverlayContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 998
                self.match(SqlBaseParser.OVERLAY)
                self.state = 999
                self.match(SqlBaseParser.T__2)
                self.state = 1000
                localctx.initial_value = self.valueExpression(0)
                self.state = 1001
                self.match(SqlBaseParser.PLACING)
                self.state = 1002
                localctx.replace = self.valueExpression(0)
                self.state = 1003
                self.match(SqlBaseParser.FROM)
                self.state = 1004
                localctx.position = self.valueExpression(0)
                self.state = 1007
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==94:
                    self.state = 1005
                    self.match(SqlBaseParser.FOR)
                    self.state = 1006
                    localctx.length = self.valueExpression(0)


                self.state = 1009
                self.match(SqlBaseParser.T__3)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1023
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,124,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1021
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
                    if la_ == 1:
                        localctx = SqlBaseParser.SubscriptContext(self, SqlBaseParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        localctx.value = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1013
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 1014
                        self.match(SqlBaseParser.T__6)
                        self.state = 1015
                        localctx.index = self.valueExpression(0)
                        self.state = 1016
                        self.match(SqlBaseParser.T__7)
                        pass

                    elif la_ == 2:
                        localctx = SqlBaseParser.DereferenceContext(self, SqlBaseParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        localctx.base = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 1018
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 1019
                        self.match(SqlBaseParser.T__4)
                        self.state = 1020
                        localctx.fieldName = self.identifier()
                        pass

             
                self.state = 1025
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,124,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_constant

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NullLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL(self):
            return self.getToken(SqlBaseParser.NULL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNullLiteral" ):
                listener.enterNullLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNullLiteral" ):
                listener.exitNullLiteral(self)


    class StringLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.STRING)
            else:
                return self.getToken(SqlBaseParser.STRING, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringLiteral" ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringLiteral" ):
                listener.exitStringLiteral(self)


    class TypeConstructorContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTypeConstructor" ):
                listener.enterTypeConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTypeConstructor" ):
                listener.exitTypeConstructor(self)


    class IntervalLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def interval(self):
            return self.getTypedRuleContext(SqlBaseParser.IntervalContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalLiteral" ):
                listener.enterIntervalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalLiteral" ):
                listener.exitIntervalLiteral(self)


    class NumericLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(SqlBaseParser.NumberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumericLiteral" ):
                listener.enterNumericLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumericLiteral" ):
                listener.exitNumericLiteral(self)


    class BooleanLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def booleanValue(self):
            return self.getTypedRuleContext(SqlBaseParser.BooleanValueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)



    def constant(self):

        localctx = SqlBaseParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_constant)
        try:
            self.state = 1038
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.NullLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1026
                self.match(SqlBaseParser.NULL)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.IntervalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1027
                self.interval()
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.TypeConstructorContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1028
                self.identifier()
                self.state = 1029
                self.match(SqlBaseParser.STRING)
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.NumericLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1031
                self.number()
                pass

            elif la_ == 5:
                localctx = SqlBaseParser.BooleanLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1032
                self.booleanValue()
                pass

            elif la_ == 6:
                localctx = SqlBaseParser.StringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1034 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1033
                        self.match(SqlBaseParser.STRING)

                    else:
                        raise NoViableAltException(self)
                    self.state = 1036 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,125,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(SqlBaseParser.EQ, 0)

        def NEQ(self):
            return self.getToken(SqlBaseParser.NEQ, 0)

        def NEQJ(self):
            return self.getToken(SqlBaseParser.NEQJ, 0)

        def LT(self):
            return self.getToken(SqlBaseParser.LT, 0)

        def LTE(self):
            return self.getToken(SqlBaseParser.LTE, 0)

        def GT(self):
            return self.getToken(SqlBaseParser.GT, 0)

        def GTE(self):
            return self.getToken(SqlBaseParser.GTE, 0)

        def NSEQ(self):
            return self.getToken(SqlBaseParser.NSEQ, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonOperator" ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonOperator" ):
                listener.exitComparisonOperator(self)




    def comparisonOperator(self):

        localctx = SqlBaseParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1040
            _la = self._input.LA(1)
            if not(((((_la - 262)) & ~0x3f) == 0 and ((1 << (_la - 262)) & 255) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(SqlBaseParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def ASTERISK(self):
            return self.getToken(SqlBaseParser.ASTERISK, 0)

        def SLASH(self):
            return self.getToken(SqlBaseParser.SLASH, 0)

        def PERCENT(self):
            return self.getToken(SqlBaseParser.PERCENT, 0)

        def DIV(self):
            return self.getToken(SqlBaseParser.DIV, 0)

        def TILDE(self):
            return self.getToken(SqlBaseParser.TILDE, 0)

        def AMPERSAND(self):
            return self.getToken(SqlBaseParser.AMPERSAND, 0)

        def PIPE(self):
            return self.getToken(SqlBaseParser.PIPE, 0)

        def CONCAT_PIPE(self):
            return self.getToken(SqlBaseParser.CONCAT_PIPE, 0)

        def HAT(self):
            return self.getToken(SqlBaseParser.HAT, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_arithmeticOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmeticOperator" ):
                listener.enterArithmeticOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmeticOperator" ):
                listener.exitArithmeticOperator(self)




    def arithmeticOperator(self):

        localctx = SqlBaseParser.ArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_arithmeticOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1042
            _la = self._input.LA(1)
            if not(((((_la - 270)) & ~0x3f) == 0 and ((1 << (_la - 270)) & 2047) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(SqlBaseParser.OR, 0)

        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)

        def IN(self):
            return self.getToken(SqlBaseParser.IN, 0)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_predicateOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateOperator" ):
                listener.enterPredicateOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateOperator" ):
                listener.exitPredicateOperator(self)




    def predicateOperator(self):

        localctx = SqlBaseParser.PredicateOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_predicateOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1044
            _la = self._input.LA(1)
            if not(_la==15 or ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & 282574488338433) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(SqlBaseParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SqlBaseParser.FALSE, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanValue" ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanValue" ):
                listener.exitBooleanValue(self)




    def booleanValue(self):

        localctx = SqlBaseParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1046
            _la = self._input.LA(1)
            if not(_la==87 or _la==239):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL(self):
            return self.getToken(SqlBaseParser.INTERVAL, 0)

        def errorCapturingMultiUnitsInterval(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingMultiUnitsIntervalContext,0)


        def errorCapturingUnitToUnitInterval(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingUnitToUnitIntervalContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_interval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval" ):
                listener.enterInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval" ):
                listener.exitInterval(self)




    def interval(self):

        localctx = SqlBaseParser.IntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_interval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1048
            self.match(SqlBaseParser.INTERVAL)
            self.state = 1051
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                self.state = 1049
                self.errorCapturingMultiUnitsInterval()

            elif la_ == 2:
                self.state = 1050
                self.errorCapturingUnitToUnitInterval()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingMultiUnitsIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiUnitsInterval(self):
            return self.getTypedRuleContext(SqlBaseParser.MultiUnitsIntervalContext,0)


        def unitToUnitInterval(self):
            return self.getTypedRuleContext(SqlBaseParser.UnitToUnitIntervalContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_errorCapturingMultiUnitsInterval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterErrorCapturingMultiUnitsInterval" ):
                listener.enterErrorCapturingMultiUnitsInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitErrorCapturingMultiUnitsInterval" ):
                listener.exitErrorCapturingMultiUnitsInterval(self)




    def errorCapturingMultiUnitsInterval(self):

        localctx = SqlBaseParser.ErrorCapturingMultiUnitsIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_errorCapturingMultiUnitsInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1053
            self.multiUnitsInterval()
            self.state = 1055
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
            if la_ == 1:
                self.state = 1054
                self.unitToUnitInterval()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiUnitsIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intervalValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IntervalValueContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IntervalValueContext,i)


        def intervalUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IntervalUnitContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IntervalUnitContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_multiUnitsInterval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiUnitsInterval" ):
                listener.enterMultiUnitsInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiUnitsInterval" ):
                listener.exitMultiUnitsInterval(self)




    def multiUnitsInterval(self):

        localctx = SqlBaseParser.MultiUnitsIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_multiUnitsInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1060 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1057
                    self.intervalValue()
                    self.state = 1058
                    self.intervalUnit()

                else:
                    raise NoViableAltException(self)
                self.state = 1062 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,129,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingUnitToUnitIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.body = None # UnitToUnitIntervalContext
            self.error1 = None # MultiUnitsIntervalContext
            self.error2 = None # UnitToUnitIntervalContext

        def unitToUnitInterval(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.UnitToUnitIntervalContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.UnitToUnitIntervalContext,i)


        def multiUnitsInterval(self):
            return self.getTypedRuleContext(SqlBaseParser.MultiUnitsIntervalContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_errorCapturingUnitToUnitInterval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterErrorCapturingUnitToUnitInterval" ):
                listener.enterErrorCapturingUnitToUnitInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitErrorCapturingUnitToUnitInterval" ):
                listener.exitErrorCapturingUnitToUnitInterval(self)




    def errorCapturingUnitToUnitInterval(self):

        localctx = SqlBaseParser.ErrorCapturingUnitToUnitIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_errorCapturingUnitToUnitInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1064
            localctx.body = self.unitToUnitInterval()
            self.state = 1067
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
            if la_ == 1:
                self.state = 1065
                localctx.error1 = self.multiUnitsInterval()

            elif la_ == 2:
                self.state = 1066
                localctx.error2 = self.unitToUnitInterval()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitToUnitIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # IntervalValueContext
            self.from_ = None # IntervalUnitContext
            self.to = None # IntervalUnitContext

        def TO(self):
            return self.getToken(SqlBaseParser.TO, 0)

        def intervalValue(self):
            return self.getTypedRuleContext(SqlBaseParser.IntervalValueContext,0)


        def intervalUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IntervalUnitContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IntervalUnitContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_unitToUnitInterval

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnitToUnitInterval" ):
                listener.enterUnitToUnitInterval(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnitToUnitInterval" ):
                listener.exitUnitToUnitInterval(self)




    def unitToUnitInterval(self):

        localctx = SqlBaseParser.UnitToUnitIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_unitToUnitInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1069
            localctx.value = self.intervalValue()
            self.state = 1070
            localctx.from_ = self.intervalUnit()
            self.state = 1071
            self.match(SqlBaseParser.TO)
            self.state = 1072
            localctx.to = self.intervalUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_VALUE(self):
            return self.getToken(SqlBaseParser.INTEGER_VALUE, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlBaseParser.DECIMAL_VALUE, 0)

        def PLUS(self):
            return self.getToken(SqlBaseParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def STRING(self):
            return self.getToken(SqlBaseParser.STRING, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_intervalValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalValue" ):
                listener.enterIntervalValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalValue" ):
                listener.exitIntervalValue(self)




    def intervalValue(self):

        localctx = SqlBaseParser.IntervalValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_intervalValue)
        self._la = 0 # Token type
        try:
            self.state = 1079
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [270, 271, 285, 287]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1075
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==270 or _la==271:
                    self.state = 1074
                    _la = self._input.LA(1)
                    if not(_la==270 or _la==271):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1077
                _la = self._input.LA(1)
                if not(_la==285 or _la==287):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [281]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1078
                self.match(SqlBaseParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAY(self):
            return self.getToken(SqlBaseParser.DAY, 0)

        def HOUR(self):
            return self.getToken(SqlBaseParser.HOUR, 0)

        def MINUTE(self):
            return self.getToken(SqlBaseParser.MINUTE, 0)

        def MONTH(self):
            return self.getToken(SqlBaseParser.MONTH, 0)

        def SECOND(self):
            return self.getToken(SqlBaseParser.SECOND, 0)

        def YEAR(self):
            return self.getToken(SqlBaseParser.YEAR, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_intervalUnit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntervalUnit" ):
                listener.enterIntervalUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntervalUnit" ):
                listener.exitIntervalUnit(self)




    def intervalUnit(self):

        localctx = SqlBaseParser.IntervalUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_intervalUnit)
        try:
            self.state = 1088
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,133,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1081
                self.match(SqlBaseParser.DAY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1082
                self.match(SqlBaseParser.HOUR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1083
                self.match(SqlBaseParser.MINUTE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1084
                self.match(SqlBaseParser.MONTH)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1085
                self.match(SqlBaseParser.SECOND)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1086
                self.match(SqlBaseParser.YEAR)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1087
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_dataType

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ComplexDataTypeContext(DataTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.DataTypeContext
            super().__init__(parser)
            self.complexDefinition = None # Token
            self.copyFrom(ctx)

        def LT(self):
            return self.getToken(SqlBaseParser.LT, 0)
        def dataType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.DataTypeContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.DataTypeContext,i)

        def GT(self):
            return self.getToken(SqlBaseParser.GT, 0)
        def ARRAY(self):
            return self.getToken(SqlBaseParser.ARRAY, 0)
        def MAP(self):
            return self.getToken(SqlBaseParser.MAP, 0)
        def STRUCT(self):
            return self.getToken(SqlBaseParser.STRUCT, 0)
        def NEQ(self):
            return self.getToken(SqlBaseParser.NEQ, 0)
        def complexColTypeList(self):
            return self.getTypedRuleContext(SqlBaseParser.ComplexColTypeListContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexDataType" ):
                listener.enterComplexDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexDataType" ):
                listener.exitComplexDataType(self)


    class PrimitiveDataTypeContext(DataTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.DataTypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)

        def INTEGER_VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.INTEGER_VALUE)
            else:
                return self.getToken(SqlBaseParser.INTEGER_VALUE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrimitiveDataType" ):
                listener.enterPrimitiveDataType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrimitiveDataType" ):
                listener.exitPrimitiveDataType(self)



    def dataType(self):

        localctx = SqlBaseParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_dataType)
        self._la = 0 # Token type
        try:
            self.state = 1124
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.ComplexDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1090
                localctx.complexDefinition = self.match(SqlBaseParser.ARRAY)
                self.state = 1091
                self.match(SqlBaseParser.LT)
                self.state = 1092
                self.dataType()
                self.state = 1093
                self.match(SqlBaseParser.GT)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.ComplexDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1095
                localctx.complexDefinition = self.match(SqlBaseParser.MAP)
                self.state = 1096
                self.match(SqlBaseParser.LT)
                self.state = 1097
                self.dataType()
                self.state = 1098
                self.match(SqlBaseParser.T__1)
                self.state = 1099
                self.dataType()
                self.state = 1100
                self.match(SqlBaseParser.GT)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.ComplexDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1102
                localctx.complexDefinition = self.match(SqlBaseParser.STRUCT)
                self.state = 1109
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [266]:
                    self.state = 1103
                    self.match(SqlBaseParser.LT)
                    self.state = 1105
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
                    if la_ == 1:
                        self.state = 1104
                        self.complexColTypeList()


                    self.state = 1107
                    self.match(SqlBaseParser.GT)
                    pass
                elif token in [264]:
                    self.state = 1108
                    self.match(SqlBaseParser.NEQ)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 4:
                localctx = SqlBaseParser.PrimitiveDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1111
                self.identifier()
                self.state = 1122
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==3:
                    self.state = 1112
                    self.match(SqlBaseParser.T__2)
                    self.state = 1113
                    self.match(SqlBaseParser.INTEGER_VALUE)
                    self.state = 1118
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 1114
                        self.match(SqlBaseParser.T__1)
                        self.state = 1115
                        self.match(SqlBaseParser.INTEGER_VALUE)
                        self.state = 1120
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1121
                    self.match(SqlBaseParser.T__3)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplexColTypeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def complexColType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ComplexColTypeContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ComplexColTypeContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_complexColTypeList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexColTypeList" ):
                listener.enterComplexColTypeList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexColTypeList" ):
                listener.exitComplexColTypeList(self)




    def complexColTypeList(self):

        localctx = SqlBaseParser.ComplexColTypeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_complexColTypeList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1126
            self.complexColType()
            self.state = 1131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 1127
                self.match(SqlBaseParser.T__1)
                self.state = 1128
                self.complexColType()
                self.state = 1133
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplexColTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def dataType(self):
            return self.getTypedRuleContext(SqlBaseParser.DataTypeContext,0)


        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def NULL(self):
            return self.getToken(SqlBaseParser.NULL, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_complexColType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComplexColType" ):
                listener.enterComplexColType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComplexColType" ):
                listener.exitComplexColType(self)




    def complexColType(self):

        localctx = SqlBaseParser.ComplexColTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_complexColType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1134
            self.identifier()
            self.state = 1135
            self.match(SqlBaseParser.T__8)
            self.state = 1136
            self.dataType()
            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==151:
                self.state = 1137
                self.match(SqlBaseParser.NOT)
                self.state = 1138
                self.match(SqlBaseParser.NULL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressionContext
            self.result = None # ExpressionContext

        def WHEN(self):
            return self.getToken(SqlBaseParser.WHEN, 0)

        def THEN(self):
            return self.getToken(SqlBaseParser.THEN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_whenClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenClause" ):
                listener.enterWhenClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenClause" ):
                listener.exitWhenClause(self)




    def whenClause(self):

        localctx = SqlBaseParser.WhenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_whenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1141
            self.match(SqlBaseParser.WHEN)
            self.state = 1142
            localctx.condition = self.expression()
            self.state = 1143
            self.match(SqlBaseParser.THEN)
            self.state = 1144
            localctx.result = self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WINDOW(self):
            return self.getToken(SqlBaseParser.WINDOW, 0)

        def namedWindow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.NamedWindowContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.NamedWindowContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_windowClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowClause" ):
                listener.enterWindowClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowClause" ):
                listener.exitWindowClause(self)




    def windowClause(self):

        localctx = SqlBaseParser.WindowClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_windowClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1146
            self.match(SqlBaseParser.WINDOW)
            self.state = 1147
            self.namedWindow()
            self.state = 1152
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,141,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1148
                    self.match(SqlBaseParser.T__1)
                    self.state = 1149
                    self.namedWindow() 
                self.state = 1154
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,141,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedWindowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # ErrorCapturingIdentifierContext

        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def windowSpec(self):
            return self.getTypedRuleContext(SqlBaseParser.WindowSpecContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_namedWindow

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNamedWindow" ):
                listener.enterNamedWindow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNamedWindow" ):
                listener.exitNamedWindow(self)




    def namedWindow(self):

        localctx = SqlBaseParser.NamedWindowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_namedWindow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1155
            localctx.name = self.errorCapturingIdentifier()
            self.state = 1156
            self.match(SqlBaseParser.AS)
            self.state = 1157
            self.windowSpec()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_windowSpec

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WindowRefContext(WindowSpecContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.WindowSpecContext
            super().__init__(parser)
            self.name = None # ErrorCapturingIdentifierContext
            self.copyFrom(ctx)

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowRef" ):
                listener.enterWindowRef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowRef" ):
                listener.exitWindowRef(self)


    class WindowDefContext(WindowSpecContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.WindowSpecContext
            super().__init__(parser)
            self._expression = None # ExpressionContext
            self.partition = list() # of ExpressionContexts
            self.copyFrom(ctx)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.BY)
            else:
                return self.getToken(SqlBaseParser.BY, i)
        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.SortItemContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.SortItemContext,i)

        def windowFrame(self):
            return self.getTypedRuleContext(SqlBaseParser.WindowFrameContext,0)

        def PARTITION(self):
            return self.getToken(SqlBaseParser.PARTITION, 0)
        def DISTRIBUTE(self):
            return self.getToken(SqlBaseParser.DISTRIBUTE, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,i)

        def ORDER(self):
            return self.getToken(SqlBaseParser.ORDER, 0)
        def SORT(self):
            return self.getToken(SqlBaseParser.SORT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowDef" ):
                listener.enterWindowDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowDef" ):
                listener.exitWindowDef(self)



    def windowSpec(self):

        localctx = SqlBaseParser.WindowSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_windowSpec)
        self._la = 0 # Token type
        try:
            self.state = 1193
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,147,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.WindowRefContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1159
                localctx.name = self.errorCapturingIdentifier()
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.WindowRefContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1160
                self.match(SqlBaseParser.T__2)
                self.state = 1161
                localctx.name = self.errorCapturingIdentifier()
                self.state = 1162
                self.match(SqlBaseParser.T__3)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.WindowDefContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1164
                self.match(SqlBaseParser.T__2)
                self.state = 1175
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==73 or _la==168:
                    self.state = 1165
                    _la = self._input.LA(1)
                    if not(_la==73 or _la==168):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1166
                    self.match(SqlBaseParser.BY)
                    self.state = 1167
                    localctx._expression = self.expression()
                    localctx.partition.append(localctx._expression)
                    self.state = 1172
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 1168
                        self.match(SqlBaseParser.T__1)
                        self.state = 1169
                        localctx._expression = self.expression()
                        localctx.partition.append(localctx._expression)
                        self.state = 1174
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1187
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==160 or _la==216:
                    self.state = 1177
                    _la = self._input.LA(1)
                    if not(_la==160 or _la==216):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1178
                    self.match(SqlBaseParser.BY)
                    self.state = 1179
                    self.sortItem()
                    self.state = 1184
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==2:
                        self.state = 1180
                        self.match(SqlBaseParser.T__1)
                        self.state = 1181
                        self.sortItem()
                        self.state = 1186
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1190
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==181 or _la==201:
                    self.state = 1189
                    self.windowFrame()


                self.state = 1192
                self.match(SqlBaseParser.T__3)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.frameType = None # Token
            self.start = None # FrameBoundContext
            self.end = None # FrameBoundContext

        def RANGE(self):
            return self.getToken(SqlBaseParser.RANGE, 0)

        def frameBound(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.FrameBoundContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.FrameBoundContext,i)


        def ROWS(self):
            return self.getToken(SqlBaseParser.ROWS, 0)

        def BETWEEN(self):
            return self.getToken(SqlBaseParser.BETWEEN, 0)

        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_windowFrame

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindowFrame" ):
                listener.enterWindowFrame(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindowFrame" ):
                listener.exitWindowFrame(self)




    def windowFrame(self):

        localctx = SqlBaseParser.WindowFrameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_windowFrame)
        try:
            self.state = 1211
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1195
                localctx.frameType = self.match(SqlBaseParser.RANGE)
                self.state = 1196
                localctx.start = self.frameBound()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1197
                localctx.frameType = self.match(SqlBaseParser.ROWS)
                self.state = 1198
                localctx.start = self.frameBound()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1199
                localctx.frameType = self.match(SqlBaseParser.RANGE)
                self.state = 1200
                self.match(SqlBaseParser.BETWEEN)
                self.state = 1201
                localctx.start = self.frameBound()
                self.state = 1202
                self.match(SqlBaseParser.AND)
                self.state = 1203
                localctx.end = self.frameBound()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1205
                localctx.frameType = self.match(SqlBaseParser.ROWS)
                self.state = 1206
                self.match(SqlBaseParser.BETWEEN)
                self.state = 1207
                localctx.start = self.frameBound()
                self.state = 1208
                self.match(SqlBaseParser.AND)
                self.state = 1209
                localctx.end = self.frameBound()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameBoundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.boundType = None # Token

        def UNBOUNDED(self):
            return self.getToken(SqlBaseParser.UNBOUNDED, 0)

        def PRECEDING(self):
            return self.getToken(SqlBaseParser.PRECEDING, 0)

        def FOLLOWING(self):
            return self.getToken(SqlBaseParser.FOLLOWING, 0)

        def ROW(self):
            return self.getToken(SqlBaseParser.ROW, 0)

        def CURRENT(self):
            return self.getToken(SqlBaseParser.CURRENT, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlBaseParser.ExpressionContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_frameBound

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrameBound" ):
                listener.enterFrameBound(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrameBound" ):
                listener.exitFrameBound(self)




    def frameBound(self):

        localctx = SqlBaseParser.FrameBoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_frameBound)
        self._la = 0 # Token type
        try:
            self.state = 1220
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1213
                self.match(SqlBaseParser.UNBOUNDED)
                self.state = 1214
                localctx.boundType = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==93 or _la==175):
                    localctx.boundType = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1215
                localctx.boundType = self.match(SqlBaseParser.CURRENT)
                self.state = 1216
                self.match(SqlBaseParser.ROW)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1217
                self.expression()
                self.state = 1218
                localctx.boundType = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==93 or _la==175):
                    localctx.boundType = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedNameListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.QualifiedNameContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_qualifiedNameList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedNameList" ):
                listener.enterQualifiedNameList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedNameList" ):
                listener.exitQualifiedNameList(self)




    def qualifiedNameList(self):

        localctx = SqlBaseParser.QualifiedNameListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_qualifiedNameList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1222
            self.qualifiedName()
            self.state = 1227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==2:
                self.state = 1223
                self.match(SqlBaseParser.T__1)
                self.state = 1224
                self.qualifiedName()
                self.state = 1229
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedName(self):
            return self.getTypedRuleContext(SqlBaseParser.QualifiedNameContext,0)


        def FILTER(self):
            return self.getToken(SqlBaseParser.FILTER, 0)

        def LEFT(self):
            return self.getToken(SqlBaseParser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(SqlBaseParser.RIGHT, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_functionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionName" ):
                listener.enterFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionName" ):
                listener.exitFunctionName(self)




    def functionName(self):

        localctx = SqlBaseParser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_functionName)
        try:
            self.state = 1234
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,151,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1230
                self.qualifiedName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1231
                self.match(SqlBaseParser.FILTER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1232
                self.match(SqlBaseParser.LEFT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1233
                self.match(SqlBaseParser.RIGHT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_qualifiedName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQualifiedName" ):
                listener.enterQualifiedName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQualifiedName" ):
                listener.exitQualifiedName(self)




    def qualifiedName(self):

        localctx = SqlBaseParser.QualifiedNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_qualifiedName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1236
            self.identifier()
            self.state = 1241
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,152,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1237
                    self.match(SqlBaseParser.T__4)
                    self.state = 1238
                    self.identifier() 
                self.state = 1243
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,152,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,0)


        def errorCapturingIdentifierExtra(self):
            return self.getTypedRuleContext(SqlBaseParser.ErrorCapturingIdentifierExtraContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_errorCapturingIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterErrorCapturingIdentifier" ):
                listener.enterErrorCapturingIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitErrorCapturingIdentifier" ):
                listener.exitErrorCapturingIdentifier(self)




    def errorCapturingIdentifier(self):

        localctx = SqlBaseParser.ErrorCapturingIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_errorCapturingIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1244
            self.identifier()
            self.state = 1245
            self.errorCapturingIdentifierExtra()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingIdentifierExtraContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_errorCapturingIdentifierExtra

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ErrorIdentContext(ErrorCapturingIdentifierExtraContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ErrorCapturingIdentifierExtraContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(SqlBaseParser.MINUS)
            else:
                return self.getToken(SqlBaseParser.MINUS, i)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlBaseParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlBaseParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterErrorIdent" ):
                listener.enterErrorIdent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitErrorIdent" ):
                listener.exitErrorIdent(self)


    class RealIdentContext(ErrorCapturingIdentifierExtraContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.ErrorCapturingIdentifierExtraContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealIdent" ):
                listener.enterRealIdent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealIdent" ):
                listener.exitRealIdent(self)



    def errorCapturingIdentifierExtra(self):

        localctx = SqlBaseParser.ErrorCapturingIdentifierExtraContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_errorCapturingIdentifierExtra)
        try:
            self.state = 1254
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,154,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.ErrorIdentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1249 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1247
                        self.match(SqlBaseParser.MINUS)
                        self.state = 1248
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1251 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,153,self._ctx)

                pass

            elif la_ == 2:
                localctx = SqlBaseParser.RealIdentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def strictIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.StrictIdentifierContext,0)


        def strictNonReserved(self):
            return self.getTypedRuleContext(SqlBaseParser.StrictNonReservedContext,0)


        def getRuleIndex(self):
            return SqlBaseParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = SqlBaseParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_identifier)
        try:
            self.state = 1259
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,155,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1256
                self.strictIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1257
                if not not self.SQL_standard_keyword_behavior:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.SQL_standard_keyword_behavior")
                self.state = 1258
                self.strictNonReserved()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StrictIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_strictIdentifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class QuotedIdentifierAlternativeContext(StrictIdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StrictIdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def quotedIdentifier(self):
            return self.getTypedRuleContext(SqlBaseParser.QuotedIdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuotedIdentifierAlternative" ):
                listener.enterQuotedIdentifierAlternative(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuotedIdentifierAlternative" ):
                listener.exitQuotedIdentifierAlternative(self)


    class UnquotedIdentifierContext(StrictIdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.StrictIdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(SqlBaseParser.IDENTIFIER, 0)
        def ansiNonReserved(self):
            return self.getTypedRuleContext(SqlBaseParser.AnsiNonReservedContext,0)

        def nonReserved(self):
            return self.getTypedRuleContext(SqlBaseParser.NonReservedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnquotedIdentifier" ):
                listener.enterUnquotedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnquotedIdentifier" ):
                listener.exitUnquotedIdentifier(self)



    def strictIdentifier(self):

        localctx = SqlBaseParser.StrictIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_strictIdentifier)
        try:
            self.state = 1267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1261
                self.match(SqlBaseParser.IDENTIFIER)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.QuotedIdentifierAlternativeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1262
                self.quotedIdentifier()
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1263
                if not self.SQL_standard_keyword_behavior:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.SQL_standard_keyword_behavior")
                self.state = 1264
                self.ansiNonReserved()
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1265
                if not not self.SQL_standard_keyword_behavior:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.SQL_standard_keyword_behavior")
                self.state = 1266
                self.nonReserved()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuotedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKQUOTED_IDENTIFIER(self):
            return self.getToken(SqlBaseParser.BACKQUOTED_IDENTIFIER, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_quotedIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuotedIdentifier" ):
                listener.enterQuotedIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuotedIdentifier" ):
                listener.exitQuotedIdentifier(self)




    def quotedIdentifier(self):

        localctx = SqlBaseParser.QuotedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_quotedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1269
            self.match(SqlBaseParser.BACKQUOTED_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlBaseParser.RULE_number

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlBaseParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecimalLiteral" ):
                listener.enterDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecimalLiteral" ):
                listener.exitDecimalLiteral(self)


    class BigIntLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BIGINT_LITERAL(self):
            return self.getToken(SqlBaseParser.BIGINT_LITERAL, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBigIntLiteral" ):
                listener.enterBigIntLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBigIntLiteral" ):
                listener.exitBigIntLiteral(self)


    class TinyIntLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TINYINT_LITERAL(self):
            return self.getToken(SqlBaseParser.TINYINT_LITERAL, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTinyIntLiteral" ):
                listener.enterTinyIntLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTinyIntLiteral" ):
                listener.exitTinyIntLiteral(self)


    class LegacyDecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXPONENT_VALUE(self):
            return self.getToken(SqlBaseParser.EXPONENT_VALUE, 0)
        def DECIMAL_VALUE(self):
            return self.getToken(SqlBaseParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLegacyDecimalLiteral" ):
                listener.enterLegacyDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLegacyDecimalLiteral" ):
                listener.exitLegacyDecimalLiteral(self)


    class BigDecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BIGDECIMAL_LITERAL(self):
            return self.getToken(SqlBaseParser.BIGDECIMAL_LITERAL, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBigDecimalLiteral" ):
                listener.enterBigDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBigDecimalLiteral" ):
                listener.exitBigDecimalLiteral(self)


    class ExponentLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXPONENT_VALUE(self):
            return self.getToken(SqlBaseParser.EXPONENT_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExponentLiteral" ):
                listener.enterExponentLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExponentLiteral" ):
                listener.exitExponentLiteral(self)


    class DoubleLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLE_LITERAL(self):
            return self.getToken(SqlBaseParser.DOUBLE_LITERAL, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleLiteral" ):
                listener.enterDoubleLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleLiteral" ):
                listener.exitDoubleLiteral(self)


    class IntegerLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTEGER_VALUE(self):
            return self.getToken(SqlBaseParser.INTEGER_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerLiteral" ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerLiteral" ):
                listener.exitIntegerLiteral(self)


    class SmallIntLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlBaseParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SMALLINT_LITERAL(self):
            return self.getToken(SqlBaseParser.SMALLINT_LITERAL, 0)
        def MINUS(self):
            return self.getToken(SqlBaseParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSmallIntLiteral" ):
                listener.enterSmallIntLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSmallIntLiteral" ):
                listener.exitSmallIntLiteral(self)



    def number(self):

        localctx = SqlBaseParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.state = 1310
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,166,self._ctx)
            if la_ == 1:
                localctx = SqlBaseParser.ExponentLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1271
                if not not self.legacy_exponent_literal_as_decimal_enabled:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.legacy_exponent_literal_as_decimal_enabled")
                self.state = 1273
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1272
                    self.match(SqlBaseParser.MINUS)


                self.state = 1275
                self.match(SqlBaseParser.EXPONENT_VALUE)
                pass

            elif la_ == 2:
                localctx = SqlBaseParser.DecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1276
                if not not self.legacy_exponent_literal_as_decimal_enabled:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.legacy_exponent_literal_as_decimal_enabled")
                self.state = 1278
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1277
                    self.match(SqlBaseParser.MINUS)


                self.state = 1280
                self.match(SqlBaseParser.DECIMAL_VALUE)
                pass

            elif la_ == 3:
                localctx = SqlBaseParser.LegacyDecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1281
                if not self.legacy_exponent_literal_as_decimal_enabled:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.legacy_exponent_literal_as_decimal_enabled")
                self.state = 1283
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1282
                    self.match(SqlBaseParser.MINUS)


                self.state = 1285
                _la = self._input.LA(1)
                if not(_la==286 or _la==287):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                localctx = SqlBaseParser.IntegerLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1287
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1286
                    self.match(SqlBaseParser.MINUS)


                self.state = 1289
                self.match(SqlBaseParser.INTEGER_VALUE)
                pass

            elif la_ == 5:
                localctx = SqlBaseParser.BigIntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1291
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1290
                    self.match(SqlBaseParser.MINUS)


                self.state = 1293
                self.match(SqlBaseParser.BIGINT_LITERAL)
                pass

            elif la_ == 6:
                localctx = SqlBaseParser.SmallIntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1295
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1294
                    self.match(SqlBaseParser.MINUS)


                self.state = 1297
                self.match(SqlBaseParser.SMALLINT_LITERAL)
                pass

            elif la_ == 7:
                localctx = SqlBaseParser.TinyIntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1299
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1298
                    self.match(SqlBaseParser.MINUS)


                self.state = 1301
                self.match(SqlBaseParser.TINYINT_LITERAL)
                pass

            elif la_ == 8:
                localctx = SqlBaseParser.DoubleLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1303
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1302
                    self.match(SqlBaseParser.MINUS)


                self.state = 1305
                self.match(SqlBaseParser.DOUBLE_LITERAL)
                pass

            elif la_ == 9:
                localctx = SqlBaseParser.BigDecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1307
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==271:
                    self.state = 1306
                    self.match(SqlBaseParser.MINUS)


                self.state = 1309
                self.match(SqlBaseParser.BIGDECIMAL_LITERAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnsiNonReservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(SqlBaseParser.ADD, 0)

        def AFTER(self):
            return self.getToken(SqlBaseParser.AFTER, 0)

        def ALTER(self):
            return self.getToken(SqlBaseParser.ALTER, 0)

        def ANALYZE(self):
            return self.getToken(SqlBaseParser.ANALYZE, 0)

        def ARCHIVE(self):
            return self.getToken(SqlBaseParser.ARCHIVE, 0)

        def ARRAY(self):
            return self.getToken(SqlBaseParser.ARRAY, 0)

        def ASC(self):
            return self.getToken(SqlBaseParser.ASC, 0)

        def AT(self):
            return self.getToken(SqlBaseParser.AT, 0)

        def BETWEEN(self):
            return self.getToken(SqlBaseParser.BETWEEN, 0)

        def BUCKET(self):
            return self.getToken(SqlBaseParser.BUCKET, 0)

        def BUCKETS(self):
            return self.getToken(SqlBaseParser.BUCKETS, 0)

        def BY(self):
            return self.getToken(SqlBaseParser.BY, 0)

        def CACHE(self):
            return self.getToken(SqlBaseParser.CACHE, 0)

        def CASCADE(self):
            return self.getToken(SqlBaseParser.CASCADE, 0)

        def CHANGE(self):
            return self.getToken(SqlBaseParser.CHANGE, 0)

        def CLEAR(self):
            return self.getToken(SqlBaseParser.CLEAR, 0)

        def CLUSTER(self):
            return self.getToken(SqlBaseParser.CLUSTER, 0)

        def CLUSTERED(self):
            return self.getToken(SqlBaseParser.CLUSTERED, 0)

        def CODEGEN(self):
            return self.getToken(SqlBaseParser.CODEGEN, 0)

        def COLLECTION(self):
            return self.getToken(SqlBaseParser.COLLECTION, 0)

        def COLUMNS(self):
            return self.getToken(SqlBaseParser.COLUMNS, 0)

        def COMMENT(self):
            return self.getToken(SqlBaseParser.COMMENT, 0)

        def COMMIT(self):
            return self.getToken(SqlBaseParser.COMMIT, 0)

        def COMPACT(self):
            return self.getToken(SqlBaseParser.COMPACT, 0)

        def COMPACTIONS(self):
            return self.getToken(SqlBaseParser.COMPACTIONS, 0)

        def COMPUTE(self):
            return self.getToken(SqlBaseParser.COMPUTE, 0)

        def CONCATENATE(self):
            return self.getToken(SqlBaseParser.CONCATENATE, 0)

        def COST(self):
            return self.getToken(SqlBaseParser.COST, 0)

        def CUBE(self):
            return self.getToken(SqlBaseParser.CUBE, 0)

        def CURRENT(self):
            return self.getToken(SqlBaseParser.CURRENT, 0)

        def DATA(self):
            return self.getToken(SqlBaseParser.DATA, 0)

        def DATABASE(self):
            return self.getToken(SqlBaseParser.DATABASE, 0)

        def DATABASES(self):
            return self.getToken(SqlBaseParser.DATABASES, 0)

        def DBPROPERTIES(self):
            return self.getToken(SqlBaseParser.DBPROPERTIES, 0)

        def DEFINED(self):
            return self.getToken(SqlBaseParser.DEFINED, 0)

        def DELETE(self):
            return self.getToken(SqlBaseParser.DELETE, 0)

        def DELIMITED(self):
            return self.getToken(SqlBaseParser.DELIMITED, 0)

        def DESC(self):
            return self.getToken(SqlBaseParser.DESC, 0)

        def DESCRIBE(self):
            return self.getToken(SqlBaseParser.DESCRIBE, 0)

        def DFS(self):
            return self.getToken(SqlBaseParser.DFS, 0)

        def DIRECTORIES(self):
            return self.getToken(SqlBaseParser.DIRECTORIES, 0)

        def DIRECTORY(self):
            return self.getToken(SqlBaseParser.DIRECTORY, 0)

        def DISTRIBUTE(self):
            return self.getToken(SqlBaseParser.DISTRIBUTE, 0)

        def DIV(self):
            return self.getToken(SqlBaseParser.DIV, 0)

        def DROP(self):
            return self.getToken(SqlBaseParser.DROP, 0)

        def ESCAPED(self):
            return self.getToken(SqlBaseParser.ESCAPED, 0)

        def EXCHANGE(self):
            return self.getToken(SqlBaseParser.EXCHANGE, 0)

        def EXISTS(self):
            return self.getToken(SqlBaseParser.EXISTS, 0)

        def EXPLAIN(self):
            return self.getToken(SqlBaseParser.EXPLAIN, 0)

        def EXPORT(self):
            return self.getToken(SqlBaseParser.EXPORT, 0)

        def EXTENDED(self):
            return self.getToken(SqlBaseParser.EXTENDED, 0)

        def EXTERNAL(self):
            return self.getToken(SqlBaseParser.EXTERNAL, 0)

        def EXTRACT(self):
            return self.getToken(SqlBaseParser.EXTRACT, 0)

        def FIELDS(self):
            return self.getToken(SqlBaseParser.FIELDS, 0)

        def FILEFORMAT(self):
            return self.getToken(SqlBaseParser.FILEFORMAT, 0)

        def FIRST(self):
            return self.getToken(SqlBaseParser.FIRST, 0)

        def FOLLOWING(self):
            return self.getToken(SqlBaseParser.FOLLOWING, 0)

        def FORMAT(self):
            return self.getToken(SqlBaseParser.FORMAT, 0)

        def FORMATTED(self):
            return self.getToken(SqlBaseParser.FORMATTED, 0)

        def FUNCTION(self):
            return self.getToken(SqlBaseParser.FUNCTION, 0)

        def FUNCTIONS(self):
            return self.getToken(SqlBaseParser.FUNCTIONS, 0)

        def GLOBAL(self):
            return self.getToken(SqlBaseParser.GLOBAL, 0)

        def GROUPING(self):
            return self.getToken(SqlBaseParser.GROUPING, 0)

        def IF(self):
            return self.getToken(SqlBaseParser.IF, 0)

        def IGNORE(self):
            return self.getToken(SqlBaseParser.IGNORE, 0)

        def IMPORT(self):
            return self.getToken(SqlBaseParser.IMPORT, 0)

        def INDEX(self):
            return self.getToken(SqlBaseParser.INDEX, 0)

        def INDEXES(self):
            return self.getToken(SqlBaseParser.INDEXES, 0)

        def INPATH(self):
            return self.getToken(SqlBaseParser.INPATH, 0)

        def INPUTFORMAT(self):
            return self.getToken(SqlBaseParser.INPUTFORMAT, 0)

        def INSERT(self):
            return self.getToken(SqlBaseParser.INSERT, 0)

        def INTERVAL(self):
            return self.getToken(SqlBaseParser.INTERVAL, 0)

        def ITEMS(self):
            return self.getToken(SqlBaseParser.ITEMS, 0)

        def KEYS(self):
            return self.getToken(SqlBaseParser.KEYS, 0)

        def LAST(self):
            return self.getToken(SqlBaseParser.LAST, 0)

        def LATERAL(self):
            return self.getToken(SqlBaseParser.LATERAL, 0)

        def LAZY(self):
            return self.getToken(SqlBaseParser.LAZY, 0)

        def LIKE(self):
            return self.getToken(SqlBaseParser.LIKE, 0)

        def LIMIT(self):
            return self.getToken(SqlBaseParser.LIMIT, 0)

        def LINES(self):
            return self.getToken(SqlBaseParser.LINES, 0)

        def LIST(self):
            return self.getToken(SqlBaseParser.LIST, 0)

        def LOAD(self):
            return self.getToken(SqlBaseParser.LOAD, 0)

        def LOCAL(self):
            return self.getToken(SqlBaseParser.LOCAL, 0)

        def LOCATION(self):
            return self.getToken(SqlBaseParser.LOCATION, 0)

        def LOCK(self):
            return self.getToken(SqlBaseParser.LOCK, 0)

        def LOCKS(self):
            return self.getToken(SqlBaseParser.LOCKS, 0)

        def LOGICAL(self):
            return self.getToken(SqlBaseParser.LOGICAL, 0)

        def MACRO(self):
            return self.getToken(SqlBaseParser.MACRO, 0)

        def MAP(self):
            return self.getToken(SqlBaseParser.MAP, 0)

        def MATCHED(self):
            return self.getToken(SqlBaseParser.MATCHED, 0)

        def MERGE(self):
            return self.getToken(SqlBaseParser.MERGE, 0)

        def MSCK(self):
            return self.getToken(SqlBaseParser.MSCK, 0)

        def NAMESPACE(self):
            return self.getToken(SqlBaseParser.NAMESPACE, 0)

        def NAMESPACES(self):
            return self.getToken(SqlBaseParser.NAMESPACES, 0)

        def NO(self):
            return self.getToken(SqlBaseParser.NO, 0)

        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def OF(self):
            return self.getToken(SqlBaseParser.OF, 0)

        def OPTION(self):
            return self.getToken(SqlBaseParser.OPTION, 0)

        def OPTIONS(self):
            return self.getToken(SqlBaseParser.OPTIONS, 0)

        def OUT(self):
            return self.getToken(SqlBaseParser.OUT, 0)

        def OUTPUTFORMAT(self):
            return self.getToken(SqlBaseParser.OUTPUTFORMAT, 0)

        def OVER(self):
            return self.getToken(SqlBaseParser.OVER, 0)

        def OVERLAY(self):
            return self.getToken(SqlBaseParser.OVERLAY, 0)

        def OVERWRITE(self):
            return self.getToken(SqlBaseParser.OVERWRITE, 0)

        def PARTITION(self):
            return self.getToken(SqlBaseParser.PARTITION, 0)

        def PARTITIONED(self):
            return self.getToken(SqlBaseParser.PARTITIONED, 0)

        def PARTITIONS(self):
            return self.getToken(SqlBaseParser.PARTITIONS, 0)

        def PERCENTLIT(self):
            return self.getToken(SqlBaseParser.PERCENTLIT, 0)

        def PIVOT(self):
            return self.getToken(SqlBaseParser.PIVOT, 0)

        def PLACING(self):
            return self.getToken(SqlBaseParser.PLACING, 0)

        def POSITION(self):
            return self.getToken(SqlBaseParser.POSITION, 0)

        def PRECEDING(self):
            return self.getToken(SqlBaseParser.PRECEDING, 0)

        def PRINCIPALS(self):
            return self.getToken(SqlBaseParser.PRINCIPALS, 0)

        def PROPERTIES(self):
            return self.getToken(SqlBaseParser.PROPERTIES, 0)

        def PURGE(self):
            return self.getToken(SqlBaseParser.PURGE, 0)

        def QUERY(self):
            return self.getToken(SqlBaseParser.QUERY, 0)

        def RANGE(self):
            return self.getToken(SqlBaseParser.RANGE, 0)

        def RECORDREADER(self):
            return self.getToken(SqlBaseParser.RECORDREADER, 0)

        def RECORDWRITER(self):
            return self.getToken(SqlBaseParser.RECORDWRITER, 0)

        def RECOVER(self):
            return self.getToken(SqlBaseParser.RECOVER, 0)

        def REDUCE(self):
            return self.getToken(SqlBaseParser.REDUCE, 0)

        def REFRESH(self):
            return self.getToken(SqlBaseParser.REFRESH, 0)

        def RENAME(self):
            return self.getToken(SqlBaseParser.RENAME, 0)

        def REPAIR(self):
            return self.getToken(SqlBaseParser.REPAIR, 0)

        def REPLACE(self):
            return self.getToken(SqlBaseParser.REPLACE, 0)

        def RESET(self):
            return self.getToken(SqlBaseParser.RESET, 0)

        def RESTRICT(self):
            return self.getToken(SqlBaseParser.RESTRICT, 0)

        def REVOKE(self):
            return self.getToken(SqlBaseParser.REVOKE, 0)

        def RLIKE(self):
            return self.getToken(SqlBaseParser.RLIKE, 0)

        def ROLE(self):
            return self.getToken(SqlBaseParser.ROLE, 0)

        def ROLES(self):
            return self.getToken(SqlBaseParser.ROLES, 0)

        def ROLLBACK(self):
            return self.getToken(SqlBaseParser.ROLLBACK, 0)

        def ROLLUP(self):
            return self.getToken(SqlBaseParser.ROLLUP, 0)

        def ROW(self):
            return self.getToken(SqlBaseParser.ROW, 0)

        def ROWS(self):
            return self.getToken(SqlBaseParser.ROWS, 0)

        def SCHEMA(self):
            return self.getToken(SqlBaseParser.SCHEMA, 0)

        def SEPARATED(self):
            return self.getToken(SqlBaseParser.SEPARATED, 0)

        def SERDE(self):
            return self.getToken(SqlBaseParser.SERDE, 0)

        def SERDEPROPERTIES(self):
            return self.getToken(SqlBaseParser.SERDEPROPERTIES, 0)

        def SET(self):
            return self.getToken(SqlBaseParser.SET, 0)

        def SETS(self):
            return self.getToken(SqlBaseParser.SETS, 0)

        def SHOW(self):
            return self.getToken(SqlBaseParser.SHOW, 0)

        def SKEWED(self):
            return self.getToken(SqlBaseParser.SKEWED, 0)

        def SORT(self):
            return self.getToken(SqlBaseParser.SORT, 0)

        def SORTED(self):
            return self.getToken(SqlBaseParser.SORTED, 0)

        def START(self):
            return self.getToken(SqlBaseParser.START, 0)

        def STATISTICS(self):
            return self.getToken(SqlBaseParser.STATISTICS, 0)

        def STORED(self):
            return self.getToken(SqlBaseParser.STORED, 0)

        def STRATIFY(self):
            return self.getToken(SqlBaseParser.STRATIFY, 0)

        def STRUCT(self):
            return self.getToken(SqlBaseParser.STRUCT, 0)

        def SUBSTR(self):
            return self.getToken(SqlBaseParser.SUBSTR, 0)

        def SUBSTRING(self):
            return self.getToken(SqlBaseParser.SUBSTRING, 0)

        def TABLES(self):
            return self.getToken(SqlBaseParser.TABLES, 0)

        def TABLESAMPLE(self):
            return self.getToken(SqlBaseParser.TABLESAMPLE, 0)

        def TBLPROPERTIES(self):
            return self.getToken(SqlBaseParser.TBLPROPERTIES, 0)

        def TEMPORARY(self):
            return self.getToken(SqlBaseParser.TEMPORARY, 0)

        def TERMINATED(self):
            return self.getToken(SqlBaseParser.TERMINATED, 0)

        def TOUCH(self):
            return self.getToken(SqlBaseParser.TOUCH, 0)

        def TRANSACTION(self):
            return self.getToken(SqlBaseParser.TRANSACTION, 0)

        def TRANSACTIONS(self):
            return self.getToken(SqlBaseParser.TRANSACTIONS, 0)

        def TRANSFORM(self):
            return self.getToken(SqlBaseParser.TRANSFORM, 0)

        def TRIM(self):
            return self.getToken(SqlBaseParser.TRIM, 0)

        def TRUE(self):
            return self.getToken(SqlBaseParser.TRUE, 0)

        def TRUNCATE(self):
            return self.getToken(SqlBaseParser.TRUNCATE, 0)

        def UNARCHIVE(self):
            return self.getToken(SqlBaseParser.UNARCHIVE, 0)

        def UNBOUNDED(self):
            return self.getToken(SqlBaseParser.UNBOUNDED, 0)

        def UNCACHE(self):
            return self.getToken(SqlBaseParser.UNCACHE, 0)

        def UNLOCK(self):
            return self.getToken(SqlBaseParser.UNLOCK, 0)

        def UNSET(self):
            return self.getToken(SqlBaseParser.UNSET, 0)

        def UPDATE(self):
            return self.getToken(SqlBaseParser.UPDATE, 0)

        def USE(self):
            return self.getToken(SqlBaseParser.USE, 0)

        def VALUES(self):
            return self.getToken(SqlBaseParser.VALUES, 0)

        def VIEW(self):
            return self.getToken(SqlBaseParser.VIEW, 0)

        def VIEWS(self):
            return self.getToken(SqlBaseParser.VIEWS, 0)

        def WINDOW(self):
            return self.getToken(SqlBaseParser.WINDOW, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_ansiNonReserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnsiNonReserved" ):
                listener.enterAnsiNonReserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnsiNonReserved" ):
                listener.exitAnsiNonReserved(self)




    def ansiNonReserved(self):

        localctx = SqlBaseParser.AnsiNonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_ansiNonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1312
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & -5159439095550940160) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -811929468582017281) != 0) or ((((_la - 130)) & ~0x3f) == 0 and ((1 << (_la - 130)) & -72128003154952193) != 0) or ((((_la - 195)) & ~0x3f) == 0 and ((1 << (_la - 195)) & 4171388029118626047) != 0) or _la==259 or _la==275):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StrictNonReservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANTI(self):
            return self.getToken(SqlBaseParser.ANTI, 0)

        def CROSS(self):
            return self.getToken(SqlBaseParser.CROSS, 0)

        def EXCEPT(self):
            return self.getToken(SqlBaseParser.EXCEPT, 0)

        def FULL(self):
            return self.getToken(SqlBaseParser.FULL, 0)

        def INNER(self):
            return self.getToken(SqlBaseParser.INNER, 0)

        def INTERSECT(self):
            return self.getToken(SqlBaseParser.INTERSECT, 0)

        def JOIN(self):
            return self.getToken(SqlBaseParser.JOIN, 0)

        def LEFT(self):
            return self.getToken(SqlBaseParser.LEFT, 0)

        def NATURAL(self):
            return self.getToken(SqlBaseParser.NATURAL, 0)

        def ON(self):
            return self.getToken(SqlBaseParser.ON, 0)

        def RIGHT(self):
            return self.getToken(SqlBaseParser.RIGHT, 0)

        def SEMI(self):
            return self.getToken(SqlBaseParser.SEMI, 0)

        def SETMINUS(self):
            return self.getToken(SqlBaseParser.SETMINUS, 0)

        def UNION(self):
            return self.getToken(SqlBaseParser.UNION, 0)

        def USING(self):
            return self.getToken(SqlBaseParser.USING, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_strictNonReserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStrictNonReserved" ):
                listener.enterStrictNonReserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStrictNonReserved" ):
                listener.exitStrictNonReserved(self)




    def strictNonReserved(self):

        localctx = SqlBaseParser.StrictNonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_strictNonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1314
            _la = self._input.LA(1)
            if not(((((_la - 16)) & ~0x3f) == 0 and ((1 << (_la - 16)) & -9223371968135299071) != 0) or ((((_la - 99)) & ~0x3f) == 0 and ((1 << (_la - 99)) & 73183495035846657) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & 578712552117241857) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NonReservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(SqlBaseParser.ADD, 0)

        def AFTER(self):
            return self.getToken(SqlBaseParser.AFTER, 0)

        def ALL(self):
            return self.getToken(SqlBaseParser.ALL, 0)

        def ALTER(self):
            return self.getToken(SqlBaseParser.ALTER, 0)

        def ANALYZE(self):
            return self.getToken(SqlBaseParser.ANALYZE, 0)

        def AND(self):
            return self.getToken(SqlBaseParser.AND, 0)

        def ANY(self):
            return self.getToken(SqlBaseParser.ANY, 0)

        def ARCHIVE(self):
            return self.getToken(SqlBaseParser.ARCHIVE, 0)

        def ARRAY(self):
            return self.getToken(SqlBaseParser.ARRAY, 0)

        def AS(self):
            return self.getToken(SqlBaseParser.AS, 0)

        def ASC(self):
            return self.getToken(SqlBaseParser.ASC, 0)

        def AT(self):
            return self.getToken(SqlBaseParser.AT, 0)

        def AUTHORIZATION(self):
            return self.getToken(SqlBaseParser.AUTHORIZATION, 0)

        def BETWEEN(self):
            return self.getToken(SqlBaseParser.BETWEEN, 0)

        def BOTH(self):
            return self.getToken(SqlBaseParser.BOTH, 0)

        def BUCKET(self):
            return self.getToken(SqlBaseParser.BUCKET, 0)

        def BUCKETS(self):
            return self.getToken(SqlBaseParser.BUCKETS, 0)

        def BY(self):
            return self.getToken(SqlBaseParser.BY, 0)

        def CACHE(self):
            return self.getToken(SqlBaseParser.CACHE, 0)

        def CASCADE(self):
            return self.getToken(SqlBaseParser.CASCADE, 0)

        def CASE(self):
            return self.getToken(SqlBaseParser.CASE, 0)

        def CAST(self):
            return self.getToken(SqlBaseParser.CAST, 0)

        def CHANGE(self):
            return self.getToken(SqlBaseParser.CHANGE, 0)

        def CHECK(self):
            return self.getToken(SqlBaseParser.CHECK, 0)

        def CLEAR(self):
            return self.getToken(SqlBaseParser.CLEAR, 0)

        def CLUSTER(self):
            return self.getToken(SqlBaseParser.CLUSTER, 0)

        def CLUSTERED(self):
            return self.getToken(SqlBaseParser.CLUSTERED, 0)

        def CODEGEN(self):
            return self.getToken(SqlBaseParser.CODEGEN, 0)

        def COLLATE(self):
            return self.getToken(SqlBaseParser.COLLATE, 0)

        def COLLECTION(self):
            return self.getToken(SqlBaseParser.COLLECTION, 0)

        def COLUMN(self):
            return self.getToken(SqlBaseParser.COLUMN, 0)

        def COLUMNS(self):
            return self.getToken(SqlBaseParser.COLUMNS, 0)

        def COMMENT(self):
            return self.getToken(SqlBaseParser.COMMENT, 0)

        def COMMIT(self):
            return self.getToken(SqlBaseParser.COMMIT, 0)

        def COMPACT(self):
            return self.getToken(SqlBaseParser.COMPACT, 0)

        def COMPACTIONS(self):
            return self.getToken(SqlBaseParser.COMPACTIONS, 0)

        def COMPUTE(self):
            return self.getToken(SqlBaseParser.COMPUTE, 0)

        def CONCATENATE(self):
            return self.getToken(SqlBaseParser.CONCATENATE, 0)

        def CONSTRAINT(self):
            return self.getToken(SqlBaseParser.CONSTRAINT, 0)

        def COST(self):
            return self.getToken(SqlBaseParser.COST, 0)

        def CREATE(self):
            return self.getToken(SqlBaseParser.CREATE, 0)

        def CUBE(self):
            return self.getToken(SqlBaseParser.CUBE, 0)

        def CURRENT(self):
            return self.getToken(SqlBaseParser.CURRENT, 0)

        def CURRENT_DATE(self):
            return self.getToken(SqlBaseParser.CURRENT_DATE, 0)

        def CURRENT_TIME(self):
            return self.getToken(SqlBaseParser.CURRENT_TIME, 0)

        def CURRENT_TIMESTAMP(self):
            return self.getToken(SqlBaseParser.CURRENT_TIMESTAMP, 0)

        def CURRENT_USER(self):
            return self.getToken(SqlBaseParser.CURRENT_USER, 0)

        def DATA(self):
            return self.getToken(SqlBaseParser.DATA, 0)

        def DATABASE(self):
            return self.getToken(SqlBaseParser.DATABASE, 0)

        def DATABASES(self):
            return self.getToken(SqlBaseParser.DATABASES, 0)

        def DAY(self):
            return self.getToken(SqlBaseParser.DAY, 0)

        def DBPROPERTIES(self):
            return self.getToken(SqlBaseParser.DBPROPERTIES, 0)

        def DEFINED(self):
            return self.getToken(SqlBaseParser.DEFINED, 0)

        def DELETE(self):
            return self.getToken(SqlBaseParser.DELETE, 0)

        def DELIMITED(self):
            return self.getToken(SqlBaseParser.DELIMITED, 0)

        def DESC(self):
            return self.getToken(SqlBaseParser.DESC, 0)

        def DESCRIBE(self):
            return self.getToken(SqlBaseParser.DESCRIBE, 0)

        def DFS(self):
            return self.getToken(SqlBaseParser.DFS, 0)

        def DIRECTORIES(self):
            return self.getToken(SqlBaseParser.DIRECTORIES, 0)

        def DIRECTORY(self):
            return self.getToken(SqlBaseParser.DIRECTORY, 0)

        def DISTINCT(self):
            return self.getToken(SqlBaseParser.DISTINCT, 0)

        def DISTRIBUTE(self):
            return self.getToken(SqlBaseParser.DISTRIBUTE, 0)

        def DIV(self):
            return self.getToken(SqlBaseParser.DIV, 0)

        def DROP(self):
            return self.getToken(SqlBaseParser.DROP, 0)

        def ELSE(self):
            return self.getToken(SqlBaseParser.ELSE, 0)

        def END(self):
            return self.getToken(SqlBaseParser.END, 0)

        def ESCAPE(self):
            return self.getToken(SqlBaseParser.ESCAPE, 0)

        def ESCAPED(self):
            return self.getToken(SqlBaseParser.ESCAPED, 0)

        def EXCHANGE(self):
            return self.getToken(SqlBaseParser.EXCHANGE, 0)

        def EXISTS(self):
            return self.getToken(SqlBaseParser.EXISTS, 0)

        def EXPLAIN(self):
            return self.getToken(SqlBaseParser.EXPLAIN, 0)

        def EXPORT(self):
            return self.getToken(SqlBaseParser.EXPORT, 0)

        def EXTENDED(self):
            return self.getToken(SqlBaseParser.EXTENDED, 0)

        def EXTERNAL(self):
            return self.getToken(SqlBaseParser.EXTERNAL, 0)

        def EXTRACT(self):
            return self.getToken(SqlBaseParser.EXTRACT, 0)

        def FALSE(self):
            return self.getToken(SqlBaseParser.FALSE, 0)

        def FETCH(self):
            return self.getToken(SqlBaseParser.FETCH, 0)

        def FILTER(self):
            return self.getToken(SqlBaseParser.FILTER, 0)

        def FIELDS(self):
            return self.getToken(SqlBaseParser.FIELDS, 0)

        def FILEFORMAT(self):
            return self.getToken(SqlBaseParser.FILEFORMAT, 0)

        def FIRST(self):
            return self.getToken(SqlBaseParser.FIRST, 0)

        def FOLLOWING(self):
            return self.getToken(SqlBaseParser.FOLLOWING, 0)

        def FOR(self):
            return self.getToken(SqlBaseParser.FOR, 0)

        def FOREIGN(self):
            return self.getToken(SqlBaseParser.FOREIGN, 0)

        def FORMAT(self):
            return self.getToken(SqlBaseParser.FORMAT, 0)

        def FORMATTED(self):
            return self.getToken(SqlBaseParser.FORMATTED, 0)

        def FROM(self):
            return self.getToken(SqlBaseParser.FROM, 0)

        def FUNCTION(self):
            return self.getToken(SqlBaseParser.FUNCTION, 0)

        def FUNCTIONS(self):
            return self.getToken(SqlBaseParser.FUNCTIONS, 0)

        def GLOBAL(self):
            return self.getToken(SqlBaseParser.GLOBAL, 0)

        def GRANT(self):
            return self.getToken(SqlBaseParser.GRANT, 0)

        def GROUP(self):
            return self.getToken(SqlBaseParser.GROUP, 0)

        def GROUPING(self):
            return self.getToken(SqlBaseParser.GROUPING, 0)

        def HAVING(self):
            return self.getToken(SqlBaseParser.HAVING, 0)

        def HOUR(self):
            return self.getToken(SqlBaseParser.HOUR, 0)

        def IF(self):
            return self.getToken(SqlBaseParser.IF, 0)

        def IGNORE(self):
            return self.getToken(SqlBaseParser.IGNORE, 0)

        def IMPORT(self):
            return self.getToken(SqlBaseParser.IMPORT, 0)

        def IN(self):
            return self.getToken(SqlBaseParser.IN, 0)

        def INDEX(self):
            return self.getToken(SqlBaseParser.INDEX, 0)

        def INDEXES(self):
            return self.getToken(SqlBaseParser.INDEXES, 0)

        def INPATH(self):
            return self.getToken(SqlBaseParser.INPATH, 0)

        def INPUTFORMAT(self):
            return self.getToken(SqlBaseParser.INPUTFORMAT, 0)

        def INSERT(self):
            return self.getToken(SqlBaseParser.INSERT, 0)

        def INTERVAL(self):
            return self.getToken(SqlBaseParser.INTERVAL, 0)

        def INTO(self):
            return self.getToken(SqlBaseParser.INTO, 0)

        def IS(self):
            return self.getToken(SqlBaseParser.IS, 0)

        def ITEMS(self):
            return self.getToken(SqlBaseParser.ITEMS, 0)

        def KEYS(self):
            return self.getToken(SqlBaseParser.KEYS, 0)

        def LAST(self):
            return self.getToken(SqlBaseParser.LAST, 0)

        def LATERAL(self):
            return self.getToken(SqlBaseParser.LATERAL, 0)

        def LAZY(self):
            return self.getToken(SqlBaseParser.LAZY, 0)

        def LEADING(self):
            return self.getToken(SqlBaseParser.LEADING, 0)

        def LIKE(self):
            return self.getToken(SqlBaseParser.LIKE, 0)

        def LIMIT(self):
            return self.getToken(SqlBaseParser.LIMIT, 0)

        def LINES(self):
            return self.getToken(SqlBaseParser.LINES, 0)

        def LIST(self):
            return self.getToken(SqlBaseParser.LIST, 0)

        def LOAD(self):
            return self.getToken(SqlBaseParser.LOAD, 0)

        def LOCAL(self):
            return self.getToken(SqlBaseParser.LOCAL, 0)

        def LOCATION(self):
            return self.getToken(SqlBaseParser.LOCATION, 0)

        def LOCK(self):
            return self.getToken(SqlBaseParser.LOCK, 0)

        def LOCKS(self):
            return self.getToken(SqlBaseParser.LOCKS, 0)

        def LOGICAL(self):
            return self.getToken(SqlBaseParser.LOGICAL, 0)

        def MACRO(self):
            return self.getToken(SqlBaseParser.MACRO, 0)

        def MAP(self):
            return self.getToken(SqlBaseParser.MAP, 0)

        def MATCHED(self):
            return self.getToken(SqlBaseParser.MATCHED, 0)

        def MERGE(self):
            return self.getToken(SqlBaseParser.MERGE, 0)

        def MINUTE(self):
            return self.getToken(SqlBaseParser.MINUTE, 0)

        def MONTH(self):
            return self.getToken(SqlBaseParser.MONTH, 0)

        def MSCK(self):
            return self.getToken(SqlBaseParser.MSCK, 0)

        def NAMESPACE(self):
            return self.getToken(SqlBaseParser.NAMESPACE, 0)

        def NAMESPACES(self):
            return self.getToken(SqlBaseParser.NAMESPACES, 0)

        def NO(self):
            return self.getToken(SqlBaseParser.NO, 0)

        def NOT(self):
            return self.getToken(SqlBaseParser.NOT, 0)

        def NULL(self):
            return self.getToken(SqlBaseParser.NULL, 0)

        def NULLS(self):
            return self.getToken(SqlBaseParser.NULLS, 0)

        def OF(self):
            return self.getToken(SqlBaseParser.OF, 0)

        def ONLY(self):
            return self.getToken(SqlBaseParser.ONLY, 0)

        def OPTION(self):
            return self.getToken(SqlBaseParser.OPTION, 0)

        def OPTIONS(self):
            return self.getToken(SqlBaseParser.OPTIONS, 0)

        def OR(self):
            return self.getToken(SqlBaseParser.OR, 0)

        def ORDER(self):
            return self.getToken(SqlBaseParser.ORDER, 0)

        def OUT(self):
            return self.getToken(SqlBaseParser.OUT, 0)

        def OUTER(self):
            return self.getToken(SqlBaseParser.OUTER, 0)

        def OUTPUTFORMAT(self):
            return self.getToken(SqlBaseParser.OUTPUTFORMAT, 0)

        def OVER(self):
            return self.getToken(SqlBaseParser.OVER, 0)

        def OVERLAPS(self):
            return self.getToken(SqlBaseParser.OVERLAPS, 0)

        def OVERLAY(self):
            return self.getToken(SqlBaseParser.OVERLAY, 0)

        def OVERWRITE(self):
            return self.getToken(SqlBaseParser.OVERWRITE, 0)

        def PARTITION(self):
            return self.getToken(SqlBaseParser.PARTITION, 0)

        def PARTITIONED(self):
            return self.getToken(SqlBaseParser.PARTITIONED, 0)

        def PARTITIONS(self):
            return self.getToken(SqlBaseParser.PARTITIONS, 0)

        def PERCENTLIT(self):
            return self.getToken(SqlBaseParser.PERCENTLIT, 0)

        def PIVOT(self):
            return self.getToken(SqlBaseParser.PIVOT, 0)

        def PLACING(self):
            return self.getToken(SqlBaseParser.PLACING, 0)

        def POSITION(self):
            return self.getToken(SqlBaseParser.POSITION, 0)

        def PRECEDING(self):
            return self.getToken(SqlBaseParser.PRECEDING, 0)

        def PRIMARY(self):
            return self.getToken(SqlBaseParser.PRIMARY, 0)

        def PRINCIPALS(self):
            return self.getToken(SqlBaseParser.PRINCIPALS, 0)

        def PROPERTIES(self):
            return self.getToken(SqlBaseParser.PROPERTIES, 0)

        def PURGE(self):
            return self.getToken(SqlBaseParser.PURGE, 0)

        def QUERY(self):
            return self.getToken(SqlBaseParser.QUERY, 0)

        def RANGE(self):
            return self.getToken(SqlBaseParser.RANGE, 0)

        def RECORDREADER(self):
            return self.getToken(SqlBaseParser.RECORDREADER, 0)

        def RECORDWRITER(self):
            return self.getToken(SqlBaseParser.RECORDWRITER, 0)

        def RECOVER(self):
            return self.getToken(SqlBaseParser.RECOVER, 0)

        def REDUCE(self):
            return self.getToken(SqlBaseParser.REDUCE, 0)

        def REFERENCES(self):
            return self.getToken(SqlBaseParser.REFERENCES, 0)

        def REFRESH(self):
            return self.getToken(SqlBaseParser.REFRESH, 0)

        def RENAME(self):
            return self.getToken(SqlBaseParser.RENAME, 0)

        def REPAIR(self):
            return self.getToken(SqlBaseParser.REPAIR, 0)

        def REPLACE(self):
            return self.getToken(SqlBaseParser.REPLACE, 0)

        def RESET(self):
            return self.getToken(SqlBaseParser.RESET, 0)

        def RESTRICT(self):
            return self.getToken(SqlBaseParser.RESTRICT, 0)

        def REVOKE(self):
            return self.getToken(SqlBaseParser.REVOKE, 0)

        def RLIKE(self):
            return self.getToken(SqlBaseParser.RLIKE, 0)

        def ROLE(self):
            return self.getToken(SqlBaseParser.ROLE, 0)

        def ROLES(self):
            return self.getToken(SqlBaseParser.ROLES, 0)

        def ROLLBACK(self):
            return self.getToken(SqlBaseParser.ROLLBACK, 0)

        def ROLLUP(self):
            return self.getToken(SqlBaseParser.ROLLUP, 0)

        def ROW(self):
            return self.getToken(SqlBaseParser.ROW, 0)

        def ROWS(self):
            return self.getToken(SqlBaseParser.ROWS, 0)

        def SCHEMA(self):
            return self.getToken(SqlBaseParser.SCHEMA, 0)

        def SECOND(self):
            return self.getToken(SqlBaseParser.SECOND, 0)

        def SELECT(self):
            return self.getToken(SqlBaseParser.SELECT, 0)

        def SEPARATED(self):
            return self.getToken(SqlBaseParser.SEPARATED, 0)

        def SERDE(self):
            return self.getToken(SqlBaseParser.SERDE, 0)

        def SERDEPROPERTIES(self):
            return self.getToken(SqlBaseParser.SERDEPROPERTIES, 0)

        def SESSION_USER(self):
            return self.getToken(SqlBaseParser.SESSION_USER, 0)

        def SET(self):
            return self.getToken(SqlBaseParser.SET, 0)

        def SETS(self):
            return self.getToken(SqlBaseParser.SETS, 0)

        def SHOW(self):
            return self.getToken(SqlBaseParser.SHOW, 0)

        def SKEWED(self):
            return self.getToken(SqlBaseParser.SKEWED, 0)

        def SOME(self):
            return self.getToken(SqlBaseParser.SOME, 0)

        def SORT(self):
            return self.getToken(SqlBaseParser.SORT, 0)

        def SORTED(self):
            return self.getToken(SqlBaseParser.SORTED, 0)

        def START(self):
            return self.getToken(SqlBaseParser.START, 0)

        def STATISTICS(self):
            return self.getToken(SqlBaseParser.STATISTICS, 0)

        def STORED(self):
            return self.getToken(SqlBaseParser.STORED, 0)

        def STRATIFY(self):
            return self.getToken(SqlBaseParser.STRATIFY, 0)

        def STRUCT(self):
            return self.getToken(SqlBaseParser.STRUCT, 0)

        def SUBSTR(self):
            return self.getToken(SqlBaseParser.SUBSTR, 0)

        def SUBSTRING(self):
            return self.getToken(SqlBaseParser.SUBSTRING, 0)

        def TABLE(self):
            return self.getToken(SqlBaseParser.TABLE, 0)

        def TABLES(self):
            return self.getToken(SqlBaseParser.TABLES, 0)

        def TABLESAMPLE(self):
            return self.getToken(SqlBaseParser.TABLESAMPLE, 0)

        def TBLPROPERTIES(self):
            return self.getToken(SqlBaseParser.TBLPROPERTIES, 0)

        def TEMPORARY(self):
            return self.getToken(SqlBaseParser.TEMPORARY, 0)

        def TERMINATED(self):
            return self.getToken(SqlBaseParser.TERMINATED, 0)

        def THEN(self):
            return self.getToken(SqlBaseParser.THEN, 0)

        def TO(self):
            return self.getToken(SqlBaseParser.TO, 0)

        def TOUCH(self):
            return self.getToken(SqlBaseParser.TOUCH, 0)

        def TRAILING(self):
            return self.getToken(SqlBaseParser.TRAILING, 0)

        def TRANSACTION(self):
            return self.getToken(SqlBaseParser.TRANSACTION, 0)

        def TRANSACTIONS(self):
            return self.getToken(SqlBaseParser.TRANSACTIONS, 0)

        def TRANSFORM(self):
            return self.getToken(SqlBaseParser.TRANSFORM, 0)

        def TRIM(self):
            return self.getToken(SqlBaseParser.TRIM, 0)

        def TRUE(self):
            return self.getToken(SqlBaseParser.TRUE, 0)

        def TRUNCATE(self):
            return self.getToken(SqlBaseParser.TRUNCATE, 0)

        def TYPE(self):
            return self.getToken(SqlBaseParser.TYPE, 0)

        def UNARCHIVE(self):
            return self.getToken(SqlBaseParser.UNARCHIVE, 0)

        def UNBOUNDED(self):
            return self.getToken(SqlBaseParser.UNBOUNDED, 0)

        def UNCACHE(self):
            return self.getToken(SqlBaseParser.UNCACHE, 0)

        def UNIQUE(self):
            return self.getToken(SqlBaseParser.UNIQUE, 0)

        def UNKNOWN(self):
            return self.getToken(SqlBaseParser.UNKNOWN, 0)

        def UNLOCK(self):
            return self.getToken(SqlBaseParser.UNLOCK, 0)

        def UNSET(self):
            return self.getToken(SqlBaseParser.UNSET, 0)

        def UPDATE(self):
            return self.getToken(SqlBaseParser.UPDATE, 0)

        def USE(self):
            return self.getToken(SqlBaseParser.USE, 0)

        def USER(self):
            return self.getToken(SqlBaseParser.USER, 0)

        def VALUES(self):
            return self.getToken(SqlBaseParser.VALUES, 0)

        def VIEW(self):
            return self.getToken(SqlBaseParser.VIEW, 0)

        def VIEWS(self):
            return self.getToken(SqlBaseParser.VIEWS, 0)

        def WHEN(self):
            return self.getToken(SqlBaseParser.WHEN, 0)

        def WHERE(self):
            return self.getToken(SqlBaseParser.WHERE, 0)

        def WINDOW(self):
            return self.getToken(SqlBaseParser.WINDOW, 0)

        def WITH(self):
            return self.getToken(SqlBaseParser.WITH, 0)

        def YEAR(self):
            return self.getToken(SqlBaseParser.YEAR, 0)

        def getRuleIndex(self):
            return SqlBaseParser.RULE_nonReserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNonReserved" ):
                listener.enterNonReserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNonReserved" ):
                listener.exitNonReserved(self)




    def nonReserved(self):

        localctx = SqlBaseParser.NonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_nonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1316
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & -4503599627437056) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & -595601085079519233) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -136314883) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & -2314850208468967429) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & 524351) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[15] = self.queryTerm_sempred
        self._predicates[49] = self.booleanExpression_sempred
        self._predicates[51] = self.valueExpression_sempred
        self._predicates[52] = self.primaryExpression_sempred
        self._predicates[79] = self.identifier_sempred
        self._predicates[80] = self.strictIdentifier_sempred
        self._predicates[82] = self.number_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def queryTerm_sempred(self, localctx:QueryTermContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.legacy_setops_precedence_enbled
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 3:
                return not self.legacy_setops_precedence_enbled
         

            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 5:
                return not self.legacy_setops_precedence_enbled
         

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         

    def valueExpression_sempred(self, localctx:ValueExpressionContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 1)
         

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 14:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 6)
         

    def identifier_sempred(self, localctx:IdentifierContext, predIndex:int):
            if predIndex == 16:
                return not self.SQL_standard_keyword_behavior
         

    def strictIdentifier_sempred(self, localctx:StrictIdentifierContext, predIndex:int):
            if predIndex == 17:
                return self.SQL_standard_keyword_behavior
         

            if predIndex == 18:
                return not self.SQL_standard_keyword_behavior
         

    def number_sempred(self, localctx:NumberContext, predIndex:int):
            if predIndex == 19:
                return not self.legacy_exponent_literal_as_decimal_enabled
         

            if predIndex == 20:
                return not self.legacy_exponent_literal_as_decimal_enabled
         

            if predIndex == 21:
                return self.legacy_exponent_literal_as_decimal_enabled
         




